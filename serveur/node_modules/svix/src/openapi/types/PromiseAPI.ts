import { ResponseContext, RequestContext, HttpFile, HttpInfo } from '../http/http';
import { Configuration} from '../configuration'

import { AggregateEventTypesOut } from '../models/AggregateEventTypesOut';
import { AppPortalAccessIn } from '../models/AppPortalAccessIn';
import { AppPortalAccessOut } from '../models/AppPortalAccessOut';
import { AppUsageStatsIn } from '../models/AppUsageStatsIn';
import { AppUsageStatsOut } from '../models/AppUsageStatsOut';
import { ApplicationIn } from '../models/ApplicationIn';
import { ApplicationOut } from '../models/ApplicationOut';
import { ApplicationPatch } from '../models/ApplicationPatch';
import { ApplicationStats } from '../models/ApplicationStats';
import { ApplicationTokenExpireIn } from '../models/ApplicationTokenExpireIn';
import { AttemptStatisticsData } from '../models/AttemptStatisticsData';
import { AttemptStatisticsResponse } from '../models/AttemptStatisticsResponse';
import { AuthTokenOut } from '../models/AuthTokenOut';
import { AzureBlobStorageConfig } from '../models/AzureBlobStorageConfig';
import { BackgroundTaskOut } from '../models/BackgroundTaskOut';
import { BackgroundTaskStatus } from '../models/BackgroundTaskStatus';
import { BackgroundTaskType } from '../models/BackgroundTaskType';
import { BigQueryConfig } from '../models/BigQueryConfig';
import { BorderRadiusConfig } from '../models/BorderRadiusConfig';
import { BorderRadiusEnum } from '../models/BorderRadiusEnum';
import { ClientSecretJwtParamsIn } from '../models/ClientSecretJwtParamsIn';
import { CompletionChoice } from '../models/CompletionChoice';
import { CompletionMessage } from '../models/CompletionMessage';
import { CreateMessageTokenIn } from '../models/CreateMessageTokenIn';
import { CreateStreamIn } from '../models/CreateStreamIn';
import { CustomColorPalette } from '../models/CustomColorPalette';
import { CustomStringsOverride } from '../models/CustomStringsOverride';
import { CustomThemeOverride } from '../models/CustomThemeOverride';
import { DashboardAccessOut } from '../models/DashboardAccessOut';
import { Duration } from '../models/Duration';
import { EndpointCreatedEvent } from '../models/EndpointCreatedEvent';
import { EndpointCreatedEventData } from '../models/EndpointCreatedEventData';
import { EndpointDeletedEvent } from '../models/EndpointDeletedEvent';
import { EndpointDeletedEventData } from '../models/EndpointDeletedEventData';
import { EndpointDisabledEvent } from '../models/EndpointDisabledEvent';
import { EndpointDisabledEventData } from '../models/EndpointDisabledEventData';
import { EndpointHeadersIn } from '../models/EndpointHeadersIn';
import { EndpointHeadersOut } from '../models/EndpointHeadersOut';
import { EndpointHeadersPatchIn } from '../models/EndpointHeadersPatchIn';
import { EndpointIn } from '../models/EndpointIn';
import { EndpointMessageOut } from '../models/EndpointMessageOut';
import { EndpointMtlsConfigIn } from '../models/EndpointMtlsConfigIn';
import { EndpointOauthConfigIn } from '../models/EndpointOauthConfigIn';
import { EndpointOut } from '../models/EndpointOut';
import { EndpointPatch } from '../models/EndpointPatch';
import { EndpointSecretOut } from '../models/EndpointSecretOut';
import { EndpointSecretRotateIn } from '../models/EndpointSecretRotateIn';
import { EndpointStats } from '../models/EndpointStats';
import { EndpointTransformationIn } from '../models/EndpointTransformationIn';
import { EndpointTransformationOut } from '../models/EndpointTransformationOut';
import { EndpointTransformationSimulateIn } from '../models/EndpointTransformationSimulateIn';
import { EndpointTransformationSimulateOut } from '../models/EndpointTransformationSimulateOut';
import { EndpointUpdate } from '../models/EndpointUpdate';
import { EndpointUpdatedEvent } from '../models/EndpointUpdatedEvent';
import { EndpointUpdatedEventData } from '../models/EndpointUpdatedEventData';
import { EnvironmentIn } from '../models/EnvironmentIn';
import { EnvironmentOut } from '../models/EnvironmentOut';
import { EnvironmentSettingsOut } from '../models/EnvironmentSettingsOut';
import { EventExampleIn } from '../models/EventExampleIn';
import { EventIn } from '../models/EventIn';
import { EventOut } from '../models/EventOut';
import { EventStreamOut } from '../models/EventStreamOut';
import { EventTypeExampleOut } from '../models/EventTypeExampleOut';
import { EventTypeFromOpenApi } from '../models/EventTypeFromOpenApi';
import { EventTypeImportOpenApiIn } from '../models/EventTypeImportOpenApiIn';
import { EventTypeImportOpenApiOut } from '../models/EventTypeImportOpenApiOut';
import { EventTypeImportOpenApiOutData } from '../models/EventTypeImportOpenApiOutData';
import { EventTypeIn } from '../models/EventTypeIn';
import { EventTypeOut } from '../models/EventTypeOut';
import { EventTypePatch } from '../models/EventTypePatch';
import { EventTypeSchemaIn } from '../models/EventTypeSchemaIn';
import { EventTypeUpdate } from '../models/EventTypeUpdate';
import { ExportEventTypeOut } from '../models/ExportEventTypeOut';
import { FontSizeConfig } from '../models/FontSizeConfig';
import { GenerateIn } from '../models/GenerateIn';
import { GenerateOut } from '../models/GenerateOut';
import { GoogleCloudStorageConfig } from '../models/GoogleCloudStorageConfig';
import { HTTPValidationError } from '../models/HTTPValidationError';
import { HttpErrorOut } from '../models/HttpErrorOut';
import { HubspotOauthConfigIn } from '../models/HubspotOauthConfigIn';
import { InboundPathParams } from '../models/InboundPathParams';
import { IncomingWebhookPayloadOut } from '../models/IncomingWebhookPayloadOut';
import { IntegrationIn } from '../models/IntegrationIn';
import { IntegrationKeyOut } from '../models/IntegrationKeyOut';
import { IntegrationOut } from '../models/IntegrationOut';
import { IntegrationUpdate } from '../models/IntegrationUpdate';
import { KafkaSecurityProtocolType } from '../models/KafkaSecurityProtocolType';
import { ListResponseApplicationOut } from '../models/ListResponseApplicationOut';
import { ListResponseApplicationStats } from '../models/ListResponseApplicationStats';
import { ListResponseBackgroundTaskOut } from '../models/ListResponseBackgroundTaskOut';
import { ListResponseEndpointMessageOut } from '../models/ListResponseEndpointMessageOut';
import { ListResponseEndpointOut } from '../models/ListResponseEndpointOut';
import { ListResponseEventTypeOut } from '../models/ListResponseEventTypeOut';
import { ListResponseIntegrationOut } from '../models/ListResponseIntegrationOut';
import { ListResponseMessageAttemptEndpointOut } from '../models/ListResponseMessageAttemptEndpointOut';
import { ListResponseMessageAttemptOut } from '../models/ListResponseMessageAttemptOut';
import { ListResponseMessageEndpointOut } from '../models/ListResponseMessageEndpointOut';
import { ListResponseMessageOut } from '../models/ListResponseMessageOut';
import { ListResponseOperationalWebhookEndpointOut } from '../models/ListResponseOperationalWebhookEndpointOut';
import { ListResponseSinkOut } from '../models/ListResponseSinkOut';
import { ListResponseStreamEventTypeOut } from '../models/ListResponseStreamEventTypeOut';
import { ListResponseStreamOut } from '../models/ListResponseStreamOut';
import { ListResponseStreamSinkOut } from '../models/ListResponseStreamSinkOut';
import { ListResponseTemplateOut } from '../models/ListResponseTemplateOut';
import { MessageAttemptEndpointOut } from '../models/MessageAttemptEndpointOut';
import { MessageAttemptExhaustedEvent } from '../models/MessageAttemptExhaustedEvent';
import { MessageAttemptExhaustedEventData } from '../models/MessageAttemptExhaustedEventData';
import { MessageAttemptFailedData } from '../models/MessageAttemptFailedData';
import { MessageAttemptFailingEvent } from '../models/MessageAttemptFailingEvent';
import { MessageAttemptFailingEventData } from '../models/MessageAttemptFailingEventData';
import { MessageAttemptHeadersOut } from '../models/MessageAttemptHeadersOut';
import { MessageAttemptOut } from '../models/MessageAttemptOut';
import { MessageAttemptRecoveredEvent } from '../models/MessageAttemptRecoveredEvent';
import { MessageAttemptRecoveredEventData } from '../models/MessageAttemptRecoveredEventData';
import { MessageAttemptTriggerType } from '../models/MessageAttemptTriggerType';
import { MessageBroadcastIn } from '../models/MessageBroadcastIn';
import { MessageBroadcastOut } from '../models/MessageBroadcastOut';
import { MessageEndpointOut } from '../models/MessageEndpointOut';
import { MessageEventsOut } from '../models/MessageEventsOut';
import { MessageIn } from '../models/MessageIn';
import { MessageOut } from '../models/MessageOut';
import { MessageRawPayloadOut } from '../models/MessageRawPayloadOut';
import { MessageStatus } from '../models/MessageStatus';
import { MessageSubscriberAuthTokenOut } from '../models/MessageSubscriberAuthTokenOut';
import { OAuthPayloadIn } from '../models/OAuthPayloadIn';
import { OAuthPayloadOut } from '../models/OAuthPayloadOut';
import { Oauth2AuthMethodIn } from '../models/Oauth2AuthMethodIn';
import { Oauth2GrantTypeIn } from '../models/Oauth2GrantTypeIn';
import { OauthJwsSigningAlgorithm } from '../models/OauthJwsSigningAlgorithm';
import { OneTimeTokenIn } from '../models/OneTimeTokenIn';
import { OneTimeTokenOut } from '../models/OneTimeTokenOut';
import { OperationalWebhookEndpointIn } from '../models/OperationalWebhookEndpointIn';
import { OperationalWebhookEndpointOut } from '../models/OperationalWebhookEndpointOut';
import { OperationalWebhookEndpointSecretIn } from '../models/OperationalWebhookEndpointSecretIn';
import { OperationalWebhookEndpointSecretOut } from '../models/OperationalWebhookEndpointSecretOut';
import { OperationalWebhookEndpointUpdate } from '../models/OperationalWebhookEndpointUpdate';
import { Ordering } from '../models/Ordering';
import { RecoverIn } from '../models/RecoverIn';
import { RecoverOut } from '../models/RecoverOut';
import { RedshiftConfig } from '../models/RedshiftConfig';
import { ReplayIn } from '../models/ReplayIn';
import { ReplayOut } from '../models/ReplayOut';
import { RetryScheduleInOut } from '../models/RetryScheduleInOut';
import { RotatedUrlOut } from '../models/RotatedUrlOut';
import { S3Config } from '../models/S3Config';
import { SettingsIn } from '../models/SettingsIn';
import { SettingsOut } from '../models/SettingsOut';
import { SinkHttpConfig } from '../models/SinkHttpConfig';
import { SinkIn } from '../models/SinkIn';
import { SinkInOneOf } from '../models/SinkInOneOf';
import { SinkInOneOf1 } from '../models/SinkInOneOf1';
import { SinkInOneOf2 } from '../models/SinkInOneOf2';
import { SinkInOneOf3 } from '../models/SinkInOneOf3';
import { SinkOtelV1Config } from '../models/SinkOtelV1Config';
import { SinkOut } from '../models/SinkOut';
import { SinkPayloadFormat } from '../models/SinkPayloadFormat';
import { SinkStatus } from '../models/SinkStatus';
import { SinkStatusIn } from '../models/SinkStatusIn';
import { SinkTransformIn } from '../models/SinkTransformIn';
import { SinkTransformationOut } from '../models/SinkTransformationOut';
import { SnowflakeConfig } from '../models/SnowflakeConfig';
import { StatisticsPeriod } from '../models/StatisticsPeriod';
import { StatusCodeClass } from '../models/StatusCodeClass';
import { StreamEventTypeIn } from '../models/StreamEventTypeIn';
import { StreamEventTypeOut } from '../models/StreamEventTypeOut';
import { StreamEventTypePatch } from '../models/StreamEventTypePatch';
import { StreamIn } from '../models/StreamIn';
import { StreamOut } from '../models/StreamOut';
import { StreamPatch } from '../models/StreamPatch';
import { StreamSinkIn } from '../models/StreamSinkIn';
import { StreamSinkInOneOf } from '../models/StreamSinkInOneOf';
import { StreamSinkInOneOf1 } from '../models/StreamSinkInOneOf1';
import { StreamSinkInOneOf2 } from '../models/StreamSinkInOneOf2';
import { StreamSinkInOneOf3 } from '../models/StreamSinkInOneOf3';
import { StreamSinkInOneOf4 } from '../models/StreamSinkInOneOf4';
import { StreamSinkInOneOf5 } from '../models/StreamSinkInOneOf5';
import { StreamSinkInOneOf6 } from '../models/StreamSinkInOneOf6';
import { StreamSinkInOneOf7 } from '../models/StreamSinkInOneOf7';
import { StreamSinkOut } from '../models/StreamSinkOut';
import { StreamSinkPatch } from '../models/StreamSinkPatch';
import { TemplateIn } from '../models/TemplateIn';
import { TemplateOut } from '../models/TemplateOut';
import { TemplatePatch } from '../models/TemplatePatch';
import { TemplateUpdate } from '../models/TemplateUpdate';
import { TransformationHttpMethod } from '../models/TransformationHttpMethod';
import { TransformationSimulateIn } from '../models/TransformationSimulateIn';
import { TransformationSimulateOut } from '../models/TransformationSimulateOut';
import { TransformationTemplateKind } from '../models/TransformationTemplateKind';
import { ValidationError } from '../models/ValidationError';
import { ObservableApplicationApi } from './ObservableAPI';

import { ApplicationApiRequestFactory, ApplicationApiResponseProcessor} from "../apis/ApplicationApi";
export class PromiseApplicationApi {
    private api: ObservableApplicationApi

    public constructor(
        configuration: Configuration,
        requestFactory?: ApplicationApiRequestFactory,
        responseProcessor?: ApplicationApiResponseProcessor
    ) {
        this.api = new ObservableApplicationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Get basic statistics for all applications.
     * Get App Usage Stats
     * @param since Filter the range to data after this date
     * @param until Filter the range to data before this date
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator to use (depends on the chosen ordering)
     */
    public getAppUsageStatsApiV1AppStatsUsageGetWithHttpInfo(since: Date, until: Date, limit?: number, iterator?: string, _options?: Configuration): Promise<HttpInfo<ListResponseApplicationStats>> {
        const result = this.api.getAppUsageStatsApiV1AppStatsUsageGetWithHttpInfo(since, until, limit, iterator, _options);
        return result.toPromise();
    }

    /**
     * Get basic statistics for all applications.
     * Get App Usage Stats
     * @param since Filter the range to data after this date
     * @param until Filter the range to data before this date
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator to use (depends on the chosen ordering)
     */
    public getAppUsageStatsApiV1AppStatsUsageGet(since: Date, until: Date, limit?: number, iterator?: string, _options?: Configuration): Promise<ListResponseApplicationStats> {
        const result = this.api.getAppUsageStatsApiV1AppStatsUsageGet(since, until, limit, iterator, _options);
        return result.toPromise();
    }

    /**
     * Create a new application.
     * Create Application
     * @param applicationIn
     * @param [getIfExists] Get an existing application, or create a new one if doesn\&#39;t exist. It\&#39;s two separate functions in the libs.
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1ApplicationCreateWithHttpInfo(applicationIn: ApplicationIn, getIfExists?: boolean, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<ApplicationOut>> {
        const result = this.api.v1ApplicationCreateWithHttpInfo(applicationIn, getIfExists, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Create a new application.
     * Create Application
     * @param applicationIn
     * @param [getIfExists] Get an existing application, or create a new one if doesn\&#39;t exist. It\&#39;s two separate functions in the libs.
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1ApplicationCreate(applicationIn: ApplicationIn, getIfExists?: boolean, idempotencyKey?: string, _options?: Configuration): Promise<ApplicationOut> {
        const result = this.api.v1ApplicationCreate(applicationIn, getIfExists, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Delete an application.
     * Delete Application
     * @param appId The app\&#39;s ID or UID
     */
    public v1ApplicationDeleteWithHttpInfo(appId: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1ApplicationDeleteWithHttpInfo(appId, _options);
        return result.toPromise();
    }

    /**
     * Delete an application.
     * Delete Application
     * @param appId The app\&#39;s ID or UID
     */
    public v1ApplicationDelete(appId: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1ApplicationDelete(appId, _options);
        return result.toPromise();
    }

    /**
     * Get an application.
     * Get Application
     * @param appId The app\&#39;s ID or UID
     */
    public v1ApplicationGetWithHttpInfo(appId: string, _options?: Configuration): Promise<HttpInfo<ApplicationOut>> {
        const result = this.api.v1ApplicationGetWithHttpInfo(appId, _options);
        return result.toPromise();
    }

    /**
     * Get an application.
     * Get Application
     * @param appId The app\&#39;s ID or UID
     */
    public v1ApplicationGet(appId: string, _options?: Configuration): Promise<ApplicationOut> {
        const result = this.api.v1ApplicationGet(appId, _options);
        return result.toPromise();
    }

    /**
     * Get basic statistics for the application
     * Get App Stats
     * @param since Filter the range to data starting from this date
     * @param until Filter the range to data ending by this date
     * @param appId The app\&#39;s ID or UID
     */
    public v1ApplicationGetStatsWithHttpInfo(since: Date, until: Date, appId: string, _options?: Configuration): Promise<HttpInfo<ApplicationStats>> {
        const result = this.api.v1ApplicationGetStatsWithHttpInfo(since, until, appId, _options);
        return result.toPromise();
    }

    /**
     * Get basic statistics for the application
     * Get App Stats
     * @param since Filter the range to data starting from this date
     * @param until Filter the range to data ending by this date
     * @param appId The app\&#39;s ID or UID
     */
    public v1ApplicationGetStats(since: Date, until: Date, appId: string, _options?: Configuration): Promise<ApplicationStats> {
        const result = this.api.v1ApplicationGetStats(since, until, appId, _options);
        return result.toPromise();
    }

    /**
     * List of all the organization\'s applications.
     * List Applications
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1ApplicationListWithHttpInfo(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<HttpInfo<ListResponseApplicationOut>> {
        const result = this.api.v1ApplicationListWithHttpInfo(limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * List of all the organization\'s applications.
     * List Applications
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1ApplicationList(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<ListResponseApplicationOut> {
        const result = this.api.v1ApplicationList(limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * Partially update an application.
     * Patch Application
     * @param appId The app\&#39;s ID or UID
     * @param applicationPatch
     */
    public v1ApplicationPatchWithHttpInfo(appId: string, applicationPatch: ApplicationPatch, _options?: Configuration): Promise<HttpInfo<ApplicationOut>> {
        const result = this.api.v1ApplicationPatchWithHttpInfo(appId, applicationPatch, _options);
        return result.toPromise();
    }

    /**
     * Partially update an application.
     * Patch Application
     * @param appId The app\&#39;s ID or UID
     * @param applicationPatch
     */
    public v1ApplicationPatch(appId: string, applicationPatch: ApplicationPatch, _options?: Configuration): Promise<ApplicationOut> {
        const result = this.api.v1ApplicationPatch(appId, applicationPatch, _options);
        return result.toPromise();
    }

    /**
     * Update an application.
     * Update Application
     * @param appId The app\&#39;s ID or UID
     * @param applicationIn
     */
    public v1ApplicationUpdateWithHttpInfo(appId: string, applicationIn: ApplicationIn, _options?: Configuration): Promise<HttpInfo<ApplicationOut>> {
        const result = this.api.v1ApplicationUpdateWithHttpInfo(appId, applicationIn, _options);
        return result.toPromise();
    }

    /**
     * Update an application.
     * Update Application
     * @param appId The app\&#39;s ID or UID
     * @param applicationIn
     */
    public v1ApplicationUpdate(appId: string, applicationIn: ApplicationIn, _options?: Configuration): Promise<ApplicationOut> {
        const result = this.api.v1ApplicationUpdate(appId, applicationIn, _options);
        return result.toPromise();
    }


}



import { ObservableAuthenticationApi } from './ObservableAPI';

import { AuthenticationApiRequestFactory, AuthenticationApiResponseProcessor} from "../apis/AuthenticationApi";
export class PromiseAuthenticationApi {
    private api: ObservableAuthenticationApi

    public constructor(
        configuration: Configuration,
        requestFactory?: AuthenticationApiRequestFactory,
        responseProcessor?: AuthenticationApiResponseProcessor
    ) {
        this.api = new ObservableAuthenticationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Use this function to get magic links (and authentication codes) for connecting your users to the Consumer Application Portal.
     * Get Consumer App Portal Access
     * @param appId The app\&#39;s ID or UID
     * @param appPortalAccessIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1AuthenticationAppPortalAccessWithHttpInfo(appId: string, appPortalAccessIn: AppPortalAccessIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<AppPortalAccessOut>> {
        const result = this.api.v1AuthenticationAppPortalAccessWithHttpInfo(appId, appPortalAccessIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Use this function to get magic links (and authentication codes) for connecting your users to the Consumer Application Portal.
     * Get Consumer App Portal Access
     * @param appId The app\&#39;s ID or UID
     * @param appPortalAccessIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1AuthenticationAppPortalAccess(appId: string, appPortalAccessIn: AppPortalAccessIn, idempotencyKey?: string, _options?: Configuration): Promise<AppPortalAccessOut> {
        const result = this.api.v1AuthenticationAppPortalAccess(appId, appPortalAccessIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Create a new access token that only allows creating messages inside this application.
     * Create Cmg Token
     * @param appId The app\&#39;s ID or UID
     * @param createMessageTokenIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1AuthenticationCreateMessageTokenWithHttpInfo(appId: string, createMessageTokenIn: CreateMessageTokenIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<AuthTokenOut>> {
        const result = this.api.v1AuthenticationCreateMessageTokenWithHttpInfo(appId, createMessageTokenIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Create a new access token that only allows creating messages inside this application.
     * Create Cmg Token
     * @param appId The app\&#39;s ID or UID
     * @param createMessageTokenIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1AuthenticationCreateMessageToken(appId: string, createMessageTokenIn: CreateMessageTokenIn, idempotencyKey?: string, _options?: Configuration): Promise<AuthTokenOut> {
        const result = this.api.v1AuthenticationCreateMessageToken(appId, createMessageTokenIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * DEPRECATED: Please use `app-portal-access` instead.  Use this function to get magic links (and authentication codes) for connecting your users to the Consumer Application Portal.
     * Dashboard Access
     * @param appId The app\&#39;s ID or UID
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1AuthenticationDashboardAccessWithHttpInfo(appId: string, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<DashboardAccessOut>> {
        const result = this.api.v1AuthenticationDashboardAccessWithHttpInfo(appId, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * DEPRECATED: Please use `app-portal-access` instead.  Use this function to get magic links (and authentication codes) for connecting your users to the Consumer Application Portal.
     * Dashboard Access
     * @param appId The app\&#39;s ID or UID
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1AuthenticationDashboardAccess(appId: string, idempotencyKey?: string, _options?: Configuration): Promise<DashboardAccessOut> {
        const result = this.api.v1AuthenticationDashboardAccess(appId, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * This is a one time token
     * Exchange One Time Token
     * @param oneTimeTokenIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1AuthenticationExchangeOneTimeTokenWithHttpInfo(oneTimeTokenIn: OneTimeTokenIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<OneTimeTokenOut>> {
        const result = this.api.v1AuthenticationExchangeOneTimeTokenWithHttpInfo(oneTimeTokenIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * This is a one time token
     * Exchange One Time Token
     * @param oneTimeTokenIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1AuthenticationExchangeOneTimeToken(oneTimeTokenIn: OneTimeTokenIn, idempotencyKey?: string, _options?: Configuration): Promise<OneTimeTokenOut> {
        const result = this.api.v1AuthenticationExchangeOneTimeToken(oneTimeTokenIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Expire all of the tokens associated with a specific Application
     * Expire All
     * @param appId The app\&#39;s ID or UID
     * @param applicationTokenExpireIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1AuthenticationExpireAllWithHttpInfo(appId: string, applicationTokenExpireIn: ApplicationTokenExpireIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1AuthenticationExpireAllWithHttpInfo(appId, applicationTokenExpireIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Expire all of the tokens associated with a specific Application
     * Expire All
     * @param appId The app\&#39;s ID or UID
     * @param applicationTokenExpireIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1AuthenticationExpireAll(appId: string, applicationTokenExpireIn: ApplicationTokenExpireIn, idempotencyKey?: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1AuthenticationExpireAll(appId, applicationTokenExpireIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Logout an app token.  Trying to log out other tokens will fail.
     * Logout
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1AuthenticationLogoutWithHttpInfo(idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1AuthenticationLogoutWithHttpInfo(idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Logout an app token.  Trying to log out other tokens will fail.
     * Logout
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1AuthenticationLogout(idempotencyKey?: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1AuthenticationLogout(idempotencyKey, _options);
        return result.toPromise();
    }


}



import { ObservableBackgroundTasksApi } from './ObservableAPI';

import { BackgroundTasksApiRequestFactory, BackgroundTasksApiResponseProcessor} from "../apis/BackgroundTasksApi";
export class PromiseBackgroundTasksApi {
    private api: ObservableBackgroundTasksApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BackgroundTasksApiRequestFactory,
        responseProcessor?: BackgroundTasksApiResponseProcessor
    ) {
        this.api = new ObservableBackgroundTasksApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Get a background task by ID.
     * Get Background Task
     * @param taskId
     */
    public getBackgroundTaskWithHttpInfo(taskId: string, _options?: Configuration): Promise<HttpInfo<BackgroundTaskOut>> {
        const result = this.api.getBackgroundTaskWithHttpInfo(taskId, _options);
        return result.toPromise();
    }

    /**
     * Get a background task by ID.
     * Get Background Task
     * @param taskId
     */
    public getBackgroundTask(taskId: string, _options?: Configuration): Promise<BackgroundTaskOut> {
        const result = this.api.getBackgroundTask(taskId, _options);
        return result.toPromise();
    }

    /**
     * List background tasks executed in the past 90 days.
     * List Background Tasks
     * @param [status] Filter the response based on the status
     * @param [task] Filter the response based on the type
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public listBackgroundTasksWithHttpInfo(status?: BackgroundTaskStatus, task?: BackgroundTaskType, limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<HttpInfo<ListResponseBackgroundTaskOut>> {
        const result = this.api.listBackgroundTasksWithHttpInfo(status, task, limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * List background tasks executed in the past 90 days.
     * List Background Tasks
     * @param [status] Filter the response based on the status
     * @param [task] Filter the response based on the type
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public listBackgroundTasks(status?: BackgroundTaskStatus, task?: BackgroundTaskType, limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<ListResponseBackgroundTaskOut> {
        const result = this.api.listBackgroundTasks(status, task, limit, iterator, order, _options);
        return result.toPromise();
    }


}



import { ObservableBroadcastApi } from './ObservableAPI';

import { BroadcastApiRequestFactory, BroadcastApiResponseProcessor} from "../apis/BroadcastApi";
export class PromiseBroadcastApi {
    private api: ObservableBroadcastApi

    public constructor(
        configuration: Configuration,
        requestFactory?: BroadcastApiRequestFactory,
        responseProcessor?: BroadcastApiResponseProcessor
    ) {
        this.api = new ObservableBroadcastApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Creates a background task to send the same message to each application in your organization
     * Create Broadcast Message
     * @param messageBroadcastIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public createBroadcastMessageWithHttpInfo(messageBroadcastIn: MessageBroadcastIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<MessageBroadcastOut>> {
        const result = this.api.createBroadcastMessageWithHttpInfo(messageBroadcastIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Creates a background task to send the same message to each application in your organization
     * Create Broadcast Message
     * @param messageBroadcastIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public createBroadcastMessage(messageBroadcastIn: MessageBroadcastIn, idempotencyKey?: string, _options?: Configuration): Promise<MessageBroadcastOut> {
        const result = this.api.createBroadcastMessage(messageBroadcastIn, idempotencyKey, _options);
        return result.toPromise();
    }


}



import { ObservableEndpointApi } from './ObservableAPI';

import { EndpointApiRequestFactory, EndpointApiResponseProcessor} from "../apis/EndpointApi";
export class PromiseEndpointApi {
    private api: ObservableEndpointApi

    public constructor(
        configuration: Configuration,
        requestFactory?: EndpointApiRequestFactory,
        responseProcessor?: EndpointApiResponseProcessor
    ) {
        this.api = new ObservableEndpointApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create a new endpoint for the application.  When `secret` is `null` the secret is automatically generated (recommended)
     * Create Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EndpointCreateWithHttpInfo(appId: string, endpointIn: EndpointIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<EndpointOut>> {
        const result = this.api.v1EndpointCreateWithHttpInfo(appId, endpointIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Create a new endpoint for the application.  When `secret` is `null` the secret is automatically generated (recommended)
     * Create Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EndpointCreate(appId: string, endpointIn: EndpointIn, idempotencyKey?: string, _options?: Configuration): Promise<EndpointOut> {
        const result = this.api.v1EndpointCreate(appId, endpointIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Delete an endpoint.
     * Delete Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointDeleteWithHttpInfo(appId: string, endpointId: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1EndpointDeleteWithHttpInfo(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Delete an endpoint.
     * Delete Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointDelete(appId: string, endpointId: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1EndpointDelete(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Delete endpoint mTLS configuration
     * Delete Endpoint Mtls Config
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointDeleteMtlsConfigWithHttpInfo(appId: string, endpointId: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1EndpointDeleteMtlsConfigWithHttpInfo(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Delete endpoint mTLS configuration
     * Delete Endpoint Mtls Config
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointDeleteMtlsConfig(appId: string, endpointId: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1EndpointDeleteMtlsConfig(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Delete endpoint OAuth configuration
     * Delete Endpoint Oauth Config
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointDeleteOauthConfigWithHttpInfo(appId: string, endpointId: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1EndpointDeleteOauthConfigWithHttpInfo(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Delete endpoint OAuth configuration
     * Delete Endpoint Oauth Config
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointDeleteOauthConfig(appId: string, endpointId: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1EndpointDeleteOauthConfig(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Get an endpoint.
     * Get Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointGetWithHttpInfo(appId: string, endpointId: string, _options?: Configuration): Promise<HttpInfo<EndpointOut>> {
        const result = this.api.v1EndpointGetWithHttpInfo(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Get an endpoint.
     * Get Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointGet(appId: string, endpointId: string, _options?: Configuration): Promise<EndpointOut> {
        const result = this.api.v1EndpointGet(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Get the additional headers to be sent with the webhook
     * Get Endpoint Headers
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointGetHeadersWithHttpInfo(appId: string, endpointId: string, _options?: Configuration): Promise<HttpInfo<EndpointHeadersOut>> {
        const result = this.api.v1EndpointGetHeadersWithHttpInfo(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Get the additional headers to be sent with the webhook
     * Get Endpoint Headers
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointGetHeaders(appId: string, endpointId: string, _options?: Configuration): Promise<EndpointHeadersOut> {
        const result = this.api.v1EndpointGetHeaders(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Get the endpoint\'s signing secret.  This is used to verify the authenticity of the webhook. For more information please refer to [the consuming webhooks docs](https://docs.svix.com/consuming-webhooks/).
     * Get Endpoint Secret
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointGetSecretWithHttpInfo(appId: string, endpointId: string, _options?: Configuration): Promise<HttpInfo<EndpointSecretOut>> {
        const result = this.api.v1EndpointGetSecretWithHttpInfo(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Get the endpoint\'s signing secret.  This is used to verify the authenticity of the webhook. For more information please refer to [the consuming webhooks docs](https://docs.svix.com/consuming-webhooks/).
     * Get Endpoint Secret
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointGetSecret(appId: string, endpointId: string, _options?: Configuration): Promise<EndpointSecretOut> {
        const result = this.api.v1EndpointGetSecret(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Get basic statistics for the endpoint.
     * Endpoint Stats
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param [since] Filter the range to data starting from this date
     * @param [until] Filter the range to data ending by this date
     */
    public v1EndpointGetStatsWithHttpInfo(appId: string, endpointId: string, since?: Date, until?: Date, _options?: Configuration): Promise<HttpInfo<EndpointStats>> {
        const result = this.api.v1EndpointGetStatsWithHttpInfo(appId, endpointId, since, until, _options);
        return result.toPromise();
    }

    /**
     * Get basic statistics for the endpoint.
     * Endpoint Stats
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param [since] Filter the range to data starting from this date
     * @param [until] Filter the range to data ending by this date
     */
    public v1EndpointGetStats(appId: string, endpointId: string, since?: Date, until?: Date, _options?: Configuration): Promise<EndpointStats> {
        const result = this.api.v1EndpointGetStats(appId, endpointId, since, until, _options);
        return result.toPromise();
    }

    /**
     * List the application\'s endpoints.
     * List Endpoints
     * @param appId The app\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1EndpointListWithHttpInfo(appId: string, limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<HttpInfo<ListResponseEndpointOut>> {
        const result = this.api.v1EndpointListWithHttpInfo(appId, limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * List the application\'s endpoints.
     * List Endpoints
     * @param appId The app\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1EndpointList(appId: string, limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<ListResponseEndpointOut> {
        const result = this.api.v1EndpointList(appId, limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * Partially update an endpoint.
     * Patch Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointPatch
     */
    public v1EndpointPatchWithHttpInfo(appId: string, endpointId: string, endpointPatch: EndpointPatch, _options?: Configuration): Promise<HttpInfo<EndpointOut>> {
        const result = this.api.v1EndpointPatchWithHttpInfo(appId, endpointId, endpointPatch, _options);
        return result.toPromise();
    }

    /**
     * Partially update an endpoint.
     * Patch Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointPatch
     */
    public v1EndpointPatch(appId: string, endpointId: string, endpointPatch: EndpointPatch, _options?: Configuration): Promise<EndpointOut> {
        const result = this.api.v1EndpointPatch(appId, endpointId, endpointPatch, _options);
        return result.toPromise();
    }

    /**
     * Partially set the additional headers to be sent with the webhook
     * Patch Endpoint Headers
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointHeadersPatchIn
     */
    public v1EndpointPatchHeadersWithHttpInfo(appId: string, endpointId: string, endpointHeadersPatchIn: EndpointHeadersPatchIn, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1EndpointPatchHeadersWithHttpInfo(appId, endpointId, endpointHeadersPatchIn, _options);
        return result.toPromise();
    }

    /**
     * Partially set the additional headers to be sent with the webhook
     * Patch Endpoint Headers
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointHeadersPatchIn
     */
    public v1EndpointPatchHeaders(appId: string, endpointId: string, endpointHeadersPatchIn: EndpointHeadersPatchIn, _options?: Configuration): Promise<void> {
        const result = this.api.v1EndpointPatchHeaders(appId, endpointId, endpointHeadersPatchIn, _options);
        return result.toPromise();
    }

    /**
     * Resend all failed messages since a given time.  Messages that were sent successfully, even if failed initially, are not resent.
     * Recover Failed Webhooks
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param recoverIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EndpointRecoverWithHttpInfo(appId: string, endpointId: string, recoverIn: RecoverIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<RecoverOut>> {
        const result = this.api.v1EndpointRecoverWithHttpInfo(appId, endpointId, recoverIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Resend all failed messages since a given time.  Messages that were sent successfully, even if failed initially, are not resent.
     * Recover Failed Webhooks
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param recoverIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EndpointRecover(appId: string, endpointId: string, recoverIn: RecoverIn, idempotencyKey?: string, _options?: Configuration): Promise<RecoverOut> {
        const result = this.api.v1EndpointRecover(appId, endpointId, recoverIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Replays messages to the endpoint. Only messages that were created after `since` will be sent. Messages that were previously sent to the endpoint are not resent.
     * Replay Missing Webhooks
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param replayIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EndpointReplayWithHttpInfo(appId: string, endpointId: string, replayIn: ReplayIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<ReplayOut>> {
        const result = this.api.v1EndpointReplayWithHttpInfo(appId, endpointId, replayIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Replays messages to the endpoint. Only messages that were created after `since` will be sent. Messages that were previously sent to the endpoint are not resent.
     * Replay Missing Webhooks
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param replayIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EndpointReplay(appId: string, endpointId: string, replayIn: ReplayIn, idempotencyKey?: string, _options?: Configuration): Promise<ReplayOut> {
        const result = this.api.v1EndpointReplay(appId, endpointId, replayIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Rotates the endpoint\'s signing secret.  The previous secret will remain valid for the next 24 hours.
     * Rotate Endpoint Secret
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointSecretRotateIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EndpointRotateSecretWithHttpInfo(appId: string, endpointId: string, endpointSecretRotateIn: EndpointSecretRotateIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1EndpointRotateSecretWithHttpInfo(appId, endpointId, endpointSecretRotateIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Rotates the endpoint\'s signing secret.  The previous secret will remain valid for the next 24 hours.
     * Rotate Endpoint Secret
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointSecretRotateIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EndpointRotateSecret(appId: string, endpointId: string, endpointSecretRotateIn: EndpointSecretRotateIn, idempotencyKey?: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1EndpointRotateSecret(appId, endpointId, endpointSecretRotateIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Send an example message for an event
     * Send Event Type Example Message
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param eventExampleIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EndpointSendExampleWithHttpInfo(appId: string, endpointId: string, eventExampleIn: EventExampleIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<MessageOut>> {
        const result = this.api.v1EndpointSendExampleWithHttpInfo(appId, endpointId, eventExampleIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Send an example message for an event
     * Send Event Type Example Message
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param eventExampleIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EndpointSendExample(appId: string, endpointId: string, eventExampleIn: EventExampleIn, idempotencyKey?: string, _options?: Configuration): Promise<MessageOut> {
        const result = this.api.v1EndpointSendExample(appId, endpointId, eventExampleIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Get the transformation code associated with this endpoint
     * Get Endpoint Transformation
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointTransformationGetWithHttpInfo(appId: string, endpointId: string, _options?: Configuration): Promise<HttpInfo<EndpointTransformationOut>> {
        const result = this.api.v1EndpointTransformationGetWithHttpInfo(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Get the transformation code associated with this endpoint
     * Get Endpoint Transformation
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     */
    public v1EndpointTransformationGet(appId: string, endpointId: string, _options?: Configuration): Promise<EndpointTransformationOut> {
        const result = this.api.v1EndpointTransformationGet(appId, endpointId, _options);
        return result.toPromise();
    }

    /**
     * Set or unset the transformation code associated with this endpoint
     * Set Endpoint Transformation
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointTransformationIn
     */
    public v1EndpointTransformationPartialUpdateWithHttpInfo(appId: string, endpointId: string, endpointTransformationIn: EndpointTransformationIn, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1EndpointTransformationPartialUpdateWithHttpInfo(appId, endpointId, endpointTransformationIn, _options);
        return result.toPromise();
    }

    /**
     * Set or unset the transformation code associated with this endpoint
     * Set Endpoint Transformation
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointTransformationIn
     */
    public v1EndpointTransformationPartialUpdate(appId: string, endpointId: string, endpointTransformationIn: EndpointTransformationIn, _options?: Configuration): Promise<void> {
        const result = this.api.v1EndpointTransformationPartialUpdate(appId, endpointId, endpointTransformationIn, _options);
        return result.toPromise();
    }

    /**
     * Simulate running the transformation on the payload and code
     * Simulate
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointTransformationSimulateIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EndpointTransformationSimulateWithHttpInfo(appId: string, endpointId: string, endpointTransformationSimulateIn: EndpointTransformationSimulateIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<EndpointTransformationSimulateOut>> {
        const result = this.api.v1EndpointTransformationSimulateWithHttpInfo(appId, endpointId, endpointTransformationSimulateIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Simulate running the transformation on the payload and code
     * Simulate
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointTransformationSimulateIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EndpointTransformationSimulate(appId: string, endpointId: string, endpointTransformationSimulateIn: EndpointTransformationSimulateIn, idempotencyKey?: string, _options?: Configuration): Promise<EndpointTransformationSimulateOut> {
        const result = this.api.v1EndpointTransformationSimulate(appId, endpointId, endpointTransformationSimulateIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Update an endpoint.
     * Update Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointUpdate
     */
    public v1EndpointUpdateWithHttpInfo(appId: string, endpointId: string, endpointUpdate: EndpointUpdate, _options?: Configuration): Promise<HttpInfo<EndpointOut>> {
        const result = this.api.v1EndpointUpdateWithHttpInfo(appId, endpointId, endpointUpdate, _options);
        return result.toPromise();
    }

    /**
     * Update an endpoint.
     * Update Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointUpdate
     */
    public v1EndpointUpdate(appId: string, endpointId: string, endpointUpdate: EndpointUpdate, _options?: Configuration): Promise<EndpointOut> {
        const result = this.api.v1EndpointUpdate(appId, endpointId, endpointUpdate, _options);
        return result.toPromise();
    }

    /**
     * Set the additional headers to be sent with the webhook
     * Update Endpoint Headers
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointHeadersIn
     */
    public v1EndpointUpdateHeadersWithHttpInfo(appId: string, endpointId: string, endpointHeadersIn: EndpointHeadersIn, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1EndpointUpdateHeadersWithHttpInfo(appId, endpointId, endpointHeadersIn, _options);
        return result.toPromise();
    }

    /**
     * Set the additional headers to be sent with the webhook
     * Update Endpoint Headers
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointHeadersIn
     */
    public v1EndpointUpdateHeaders(appId: string, endpointId: string, endpointHeadersIn: EndpointHeadersIn, _options?: Configuration): Promise<void> {
        const result = this.api.v1EndpointUpdateHeaders(appId, endpointId, endpointHeadersIn, _options);
        return result.toPromise();
    }

    /**
     * Create/update endpoint mTLS configuration
     * Update Endpoint Mtls Config
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointMtlsConfigIn
     */
    public v1EndpointUpdateMtlsConfigWithHttpInfo(appId: string, endpointId: string, endpointMtlsConfigIn: EndpointMtlsConfigIn, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1EndpointUpdateMtlsConfigWithHttpInfo(appId, endpointId, endpointMtlsConfigIn, _options);
        return result.toPromise();
    }

    /**
     * Create/update endpoint mTLS configuration
     * Update Endpoint Mtls Config
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointMtlsConfigIn
     */
    public v1EndpointUpdateMtlsConfig(appId: string, endpointId: string, endpointMtlsConfigIn: EndpointMtlsConfigIn, _options?: Configuration): Promise<void> {
        const result = this.api.v1EndpointUpdateMtlsConfig(appId, endpointId, endpointMtlsConfigIn, _options);
        return result.toPromise();
    }

    /**
     * Create/update endpoint OAuth configuration
     * Update Endpoint Oauth Config
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointOauthConfigIn
     */
    public v1EndpointUpdateOauthConfigWithHttpInfo(appId: string, endpointId: string, endpointOauthConfigIn: EndpointOauthConfigIn, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1EndpointUpdateOauthConfigWithHttpInfo(appId, endpointId, endpointOauthConfigIn, _options);
        return result.toPromise();
    }

    /**
     * Create/update endpoint OAuth configuration
     * Update Endpoint Oauth Config
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param endpointOauthConfigIn
     */
    public v1EndpointUpdateOauthConfig(appId: string, endpointId: string, endpointOauthConfigIn: EndpointOauthConfigIn, _options?: Configuration): Promise<void> {
        const result = this.api.v1EndpointUpdateOauthConfig(appId, endpointId, endpointOauthConfigIn, _options);
        return result.toPromise();
    }

    /**
     * Create a new sink for the application.
     * Create Sink
     * @param appId The app\&#39;s ID or UID
     * @param sinkIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1SinkCreateWithHttpInfo(appId: string, sinkIn: SinkIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<SinkOut>> {
        const result = this.api.v1SinkCreateWithHttpInfo(appId, sinkIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Create a new sink for the application.
     * Create Sink
     * @param appId The app\&#39;s ID or UID
     * @param sinkIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1SinkCreate(appId: string, sinkIn: SinkIn, idempotencyKey?: string, _options?: Configuration): Promise<SinkOut> {
        const result = this.api.v1SinkCreate(appId, sinkIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Get a sink.
     * Get Sink
     * @param appId The app\&#39;s ID or UID
     * @param sinkId The ep\&#39;s ID or UID
     */
    public v1SinkGetWithHttpInfo(appId: string, sinkId: string, _options?: Configuration): Promise<HttpInfo<SinkOut>> {
        const result = this.api.v1SinkGetWithHttpInfo(appId, sinkId, _options);
        return result.toPromise();
    }

    /**
     * Get a sink.
     * Get Sink
     * @param appId The app\&#39;s ID or UID
     * @param sinkId The ep\&#39;s ID or UID
     */
    public v1SinkGet(appId: string, sinkId: string, _options?: Configuration): Promise<SinkOut> {
        const result = this.api.v1SinkGet(appId, sinkId, _options);
        return result.toPromise();
    }

    /**
     * List the application\'s sinks.
     * List Sinks
     * @param appId The app\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1SinkListWithHttpInfo(appId: string, limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<HttpInfo<ListResponseSinkOut>> {
        const result = this.api.v1SinkListWithHttpInfo(appId, limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * List the application\'s sinks.
     * List Sinks
     * @param appId The app\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1SinkList(appId: string, limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<ListResponseSinkOut> {
        const result = this.api.v1SinkList(appId, limit, iterator, order, _options);
        return result.toPromise();
    }


}



import { ObservableEnvironmentApi } from './ObservableAPI';

import { EnvironmentApiRequestFactory, EnvironmentApiResponseProcessor} from "../apis/EnvironmentApi";
export class PromiseEnvironmentApi {
    private api: ObservableEnvironmentApi

    public constructor(
        configuration: Configuration,
        requestFactory?: EnvironmentApiRequestFactory,
        responseProcessor?: EnvironmentApiResponseProcessor
    ) {
        this.api = new ObservableEnvironmentApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Download a JSON file containing all org-settings and event types
     * Export Environment Configuration
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EnvironmentExportWithHttpInfo(idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<EnvironmentOut>> {
        const result = this.api.v1EnvironmentExportWithHttpInfo(idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Download a JSON file containing all org-settings and event types
     * Export Environment Configuration
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EnvironmentExport(idempotencyKey?: string, _options?: Configuration): Promise<EnvironmentOut> {
        const result = this.api.v1EnvironmentExport(idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Download a JSON file containing all org-settings and event types
     * Export Environment Configuration
     */
    public v1EnvironmentExportGetWithHttpInfo(_options?: Configuration): Promise<HttpInfo<EnvironmentOut>> {
        const result = this.api.v1EnvironmentExportGetWithHttpInfo(_options);
        return result.toPromise();
    }

    /**
     * Download a JSON file containing all org-settings and event types
     * Export Environment Configuration
     */
    public v1EnvironmentExportGet(_options?: Configuration): Promise<EnvironmentOut> {
        const result = this.api.v1EnvironmentExportGet(_options);
        return result.toPromise();
    }

    /**
     * Import a configuration into the active organization. It doesn\'t delete anything, only adds/updates what was passed to it.
     * Import Environment Configuration
     * @param environmentIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EnvironmentImportWithHttpInfo(environmentIn: EnvironmentIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1EnvironmentImportWithHttpInfo(environmentIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Import a configuration into the active organization. It doesn\'t delete anything, only adds/updates what was passed to it.
     * Import Environment Configuration
     * @param environmentIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EnvironmentImport(environmentIn: EnvironmentIn, idempotencyKey?: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1EnvironmentImport(environmentIn, idempotencyKey, _options);
        return result.toPromise();
    }


}



import { ObservableEnvironmentSettingsApi } from './ObservableAPI';

import { EnvironmentSettingsApiRequestFactory, EnvironmentSettingsApiResponseProcessor} from "../apis/EnvironmentSettingsApi";
export class PromiseEnvironmentSettingsApi {
    private api: ObservableEnvironmentSettingsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: EnvironmentSettingsApiRequestFactory,
        responseProcessor?: EnvironmentSettingsApiResponseProcessor
    ) {
        this.api = new ObservableEnvironmentSettingsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Get the environment\'s settings
     * Get Org Settings
     */
    public v1EnvironmentGetSettingsWithHttpInfo(_options?: Configuration): Promise<HttpInfo<EnvironmentSettingsOut>> {
        const result = this.api.v1EnvironmentGetSettingsWithHttpInfo(_options);
        return result.toPromise();
    }

    /**
     * Get the environment\'s settings
     * Get Org Settings
     */
    public v1EnvironmentGetSettings(_options?: Configuration): Promise<EnvironmentSettingsOut> {
        const result = this.api.v1EnvironmentGetSettings(_options);
        return result.toPromise();
    }


}



import { ObservableEventTypeApi } from './ObservableAPI';

import { EventTypeApiRequestFactory, EventTypeApiResponseProcessor} from "../apis/EventTypeApi";
export class PromiseEventTypeApi {
    private api: ObservableEventTypeApi

    public constructor(
        configuration: Configuration,
        requestFactory?: EventTypeApiRequestFactory,
        responseProcessor?: EventTypeApiResponseProcessor
    ) {
        this.api = new ObservableEventTypeApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create new or unarchive existing event type.  Unarchiving an event type will allow endpoints to filter on it and messages to be sent with it. Endpoints filtering on the event type before archival will continue to filter on it. This operation does not preserve the description and schemas.
     * Create Event Type
     * @param eventTypeIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EventTypeCreateWithHttpInfo(eventTypeIn: EventTypeIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<EventTypeOut>> {
        const result = this.api.v1EventTypeCreateWithHttpInfo(eventTypeIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Create new or unarchive existing event type.  Unarchiving an event type will allow endpoints to filter on it and messages to be sent with it. Endpoints filtering on the event type before archival will continue to filter on it. This operation does not preserve the description and schemas.
     * Create Event Type
     * @param eventTypeIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EventTypeCreate(eventTypeIn: EventTypeIn, idempotencyKey?: string, _options?: Configuration): Promise<EventTypeOut> {
        const result = this.api.v1EventTypeCreate(eventTypeIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Archive an event type.  Endpoints already configured to filter on an event type will continue to do so after archival. However, new messages can not be sent with it and endpoints can not filter on it. An event type can be unarchived with the [create operation](#operation/create_event_type_api_v1_event_type__post).
     * Delete Event Type
     * @param eventTypeName The event type\&#39;s name
     * @param [expunge] By default event types are archived when \&quot;deleted\&quot;. Passing this to &#x60;true&#x60; deletes them entirely.
     */
    public v1EventTypeDeleteWithHttpInfo(eventTypeName: string, expunge?: boolean, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1EventTypeDeleteWithHttpInfo(eventTypeName, expunge, _options);
        return result.toPromise();
    }

    /**
     * Archive an event type.  Endpoints already configured to filter on an event type will continue to do so after archival. However, new messages can not be sent with it and endpoints can not filter on it. An event type can be unarchived with the [create operation](#operation/create_event_type_api_v1_event_type__post).
     * Delete Event Type
     * @param eventTypeName The event type\&#39;s name
     * @param [expunge] By default event types are archived when \&quot;deleted\&quot;. Passing this to &#x60;true&#x60; deletes them entirely.
     */
    public v1EventTypeDelete(eventTypeName: string, expunge?: boolean, _options?: Configuration): Promise<void> {
        const result = this.api.v1EventTypeDelete(eventTypeName, expunge, _options);
        return result.toPromise();
    }

    /**
     * Exports event type definitions based on the OpenAPI schemas associated with each existing event type
     * Event Type Export From Openapi
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EventTypeExportOpenapiWithHttpInfo(idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<ExportEventTypeOut>> {
        const result = this.api.v1EventTypeExportOpenapiWithHttpInfo(idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Exports event type definitions based on the OpenAPI schemas associated with each existing event type
     * Event Type Export From Openapi
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EventTypeExportOpenapi(idempotencyKey?: string, _options?: Configuration): Promise<ExportEventTypeOut> {
        const result = this.api.v1EventTypeExportOpenapi(idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Generates a fake example from the given JSONSchema
     * Generate Schema Example
     * @param eventTypeSchemaIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EventTypeGenerateExampleWithHttpInfo(eventTypeSchemaIn: EventTypeSchemaIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<EventTypeExampleOut>> {
        const result = this.api.v1EventTypeGenerateExampleWithHttpInfo(eventTypeSchemaIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Generates a fake example from the given JSONSchema
     * Generate Schema Example
     * @param eventTypeSchemaIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EventTypeGenerateExample(eventTypeSchemaIn: EventTypeSchemaIn, idempotencyKey?: string, _options?: Configuration): Promise<EventTypeExampleOut> {
        const result = this.api.v1EventTypeGenerateExample(eventTypeSchemaIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Get an event type.
     * Get Event Type
     * @param eventTypeName The event type\&#39;s name
     */
    public v1EventTypeGetWithHttpInfo(eventTypeName: string, _options?: Configuration): Promise<HttpInfo<EventTypeOut>> {
        const result = this.api.v1EventTypeGetWithHttpInfo(eventTypeName, _options);
        return result.toPromise();
    }

    /**
     * Get an event type.
     * Get Event Type
     * @param eventTypeName The event type\&#39;s name
     */
    public v1EventTypeGet(eventTypeName: string, _options?: Configuration): Promise<EventTypeOut> {
        const result = this.api.v1EventTypeGet(eventTypeName, _options);
        return result.toPromise();
    }

    /**
     * Gets the retry schedule for messages using the given event type
     * Get Retry Schedule
     * @param eventTypeName The event type\&#39;s name
     */
    public v1EventTypeGetRetryScheduleWithHttpInfo(eventTypeName: string, _options?: Configuration): Promise<HttpInfo<RetryScheduleInOut>> {
        const result = this.api.v1EventTypeGetRetryScheduleWithHttpInfo(eventTypeName, _options);
        return result.toPromise();
    }

    /**
     * Gets the retry schedule for messages using the given event type
     * Get Retry Schedule
     * @param eventTypeName The event type\&#39;s name
     */
    public v1EventTypeGetRetrySchedule(eventTypeName: string, _options?: Configuration): Promise<RetryScheduleInOut> {
        const result = this.api.v1EventTypeGetRetrySchedule(eventTypeName, _options);
        return result.toPromise();
    }

    /**
     * Given an OpenAPI spec, create new or update existing event types. If an existing `archived` event type is updated, it will be unarchived.  The importer will convert all webhooks found in the either the `webhooks` or `x-webhooks` top-level.
     * Event Type Import From Openapi
     * @param eventTypeImportOpenApiIn Import a list of event types from webhooks defined in an OpenAPI spec.  The OpenAPI spec can be specified as either &#x60;spec&#x60; given the spec as a JSON object, or as &#x60;specRaw&#x60; (a &#x60;string&#x60;) which will be parsed as YAML or JSON by the server. Sending neither or both is invalid, resulting in a &#x60;400&#x60; **Bad Request**.
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EventTypeImportOpenapiWithHttpInfo(eventTypeImportOpenApiIn: EventTypeImportOpenApiIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<EventTypeImportOpenApiOut>> {
        const result = this.api.v1EventTypeImportOpenapiWithHttpInfo(eventTypeImportOpenApiIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Given an OpenAPI spec, create new or update existing event types. If an existing `archived` event type is updated, it will be unarchived.  The importer will convert all webhooks found in the either the `webhooks` or `x-webhooks` top-level.
     * Event Type Import From Openapi
     * @param eventTypeImportOpenApiIn Import a list of event types from webhooks defined in an OpenAPI spec.  The OpenAPI spec can be specified as either &#x60;spec&#x60; given the spec as a JSON object, or as &#x60;specRaw&#x60; (a &#x60;string&#x60;) which will be parsed as YAML or JSON by the server. Sending neither or both is invalid, resulting in a &#x60;400&#x60; **Bad Request**.
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1EventTypeImportOpenapi(eventTypeImportOpenApiIn: EventTypeImportOpenApiIn, idempotencyKey?: string, _options?: Configuration): Promise<EventTypeImportOpenApiOut> {
        const result = this.api.v1EventTypeImportOpenapi(eventTypeImportOpenApiIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Return the list of event types.
     * List Event Types
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     * @param [includeArchived] When &#x60;true&#x60; archived (deleted but not expunged) items are included in the response
     * @param [withContent] When &#x60;true&#x60; the full item (including the schema) is included in the response
     */
    public v1EventTypeListWithHttpInfo(limit?: number, iterator?: string, order?: Ordering, includeArchived?: boolean, withContent?: boolean, _options?: Configuration): Promise<HttpInfo<ListResponseEventTypeOut>> {
        const result = this.api.v1EventTypeListWithHttpInfo(limit, iterator, order, includeArchived, withContent, _options);
        return result.toPromise();
    }

    /**
     * Return the list of event types.
     * List Event Types
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     * @param [includeArchived] When &#x60;true&#x60; archived (deleted but not expunged) items are included in the response
     * @param [withContent] When &#x60;true&#x60; the full item (including the schema) is included in the response
     */
    public v1EventTypeList(limit?: number, iterator?: string, order?: Ordering, includeArchived?: boolean, withContent?: boolean, _options?: Configuration): Promise<ListResponseEventTypeOut> {
        const result = this.api.v1EventTypeList(limit, iterator, order, includeArchived, withContent, _options);
        return result.toPromise();
    }

    /**
     * Partially update an event type.
     * Patch Event Type
     * @param eventTypeName The event type\&#39;s name
     * @param eventTypePatch
     */
    public v1EventTypePatchWithHttpInfo(eventTypeName: string, eventTypePatch: EventTypePatch, _options?: Configuration): Promise<HttpInfo<EventTypeOut>> {
        const result = this.api.v1EventTypePatchWithHttpInfo(eventTypeName, eventTypePatch, _options);
        return result.toPromise();
    }

    /**
     * Partially update an event type.
     * Patch Event Type
     * @param eventTypeName The event type\&#39;s name
     * @param eventTypePatch
     */
    public v1EventTypePatch(eventTypeName: string, eventTypePatch: EventTypePatch, _options?: Configuration): Promise<EventTypeOut> {
        const result = this.api.v1EventTypePatch(eventTypeName, eventTypePatch, _options);
        return result.toPromise();
    }

    /**
     * Update an event type.
     * Update Event Type
     * @param eventTypeName The event type\&#39;s name
     * @param eventTypeUpdate
     */
    public v1EventTypeUpdateWithHttpInfo(eventTypeName: string, eventTypeUpdate: EventTypeUpdate, _options?: Configuration): Promise<HttpInfo<EventTypeOut>> {
        const result = this.api.v1EventTypeUpdateWithHttpInfo(eventTypeName, eventTypeUpdate, _options);
        return result.toPromise();
    }

    /**
     * Update an event type.
     * Update Event Type
     * @param eventTypeName The event type\&#39;s name
     * @param eventTypeUpdate
     */
    public v1EventTypeUpdate(eventTypeName: string, eventTypeUpdate: EventTypeUpdate, _options?: Configuration): Promise<EventTypeOut> {
        const result = this.api.v1EventTypeUpdate(eventTypeName, eventTypeUpdate, _options);
        return result.toPromise();
    }

    /**
     * Sets a retry schedule for all messages using the given event type
     * Update Retry Schedule
     * @param eventTypeName The event type\&#39;s name
     * @param retryScheduleInOut
     */
    public v1EventTypeUpdateRetryScheduleWithHttpInfo(eventTypeName: string, retryScheduleInOut: RetryScheduleInOut, _options?: Configuration): Promise<HttpInfo<RetryScheduleInOut>> {
        const result = this.api.v1EventTypeUpdateRetryScheduleWithHttpInfo(eventTypeName, retryScheduleInOut, _options);
        return result.toPromise();
    }

    /**
     * Sets a retry schedule for all messages using the given event type
     * Update Retry Schedule
     * @param eventTypeName The event type\&#39;s name
     * @param retryScheduleInOut
     */
    public v1EventTypeUpdateRetrySchedule(eventTypeName: string, retryScheduleInOut: RetryScheduleInOut, _options?: Configuration): Promise<RetryScheduleInOut> {
        const result = this.api.v1EventTypeUpdateRetrySchedule(eventTypeName, retryScheduleInOut, _options);
        return result.toPromise();
    }


}



import { ObservableEventsApi } from './ObservableAPI';

import { EventsApiRequestFactory, EventsApiResponseProcessor} from "../apis/EventsApi";
export class PromiseEventsApi {
    private api: ObservableEventsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: EventsApiRequestFactory,
        responseProcessor?: EventsApiResponseProcessor
    ) {
        this.api = new ObservableEventsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Reads the stream of operational webhook events for this environment
     * Events
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [eventTypes] Filter response based on the event type
     * @param [channels] Filter response based on the event type
     * @param [after]
     */
    public v1EventsWithHttpInfo(limit?: number, iterator?: string, eventTypes?: Array<string>, channels?: Array<string>, after?: Date, _options?: Configuration): Promise<HttpInfo<MessageEventsOut>> {
        const result = this.api.v1EventsWithHttpInfo(limit, iterator, eventTypes, channels, after, _options);
        return result.toPromise();
    }

    /**
     * Reads the stream of operational webhook events for this environment
     * Events
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [eventTypes] Filter response based on the event type
     * @param [channels] Filter response based on the event type
     * @param [after]
     */
    public v1Events(limit?: number, iterator?: string, eventTypes?: Array<string>, channels?: Array<string>, after?: Date, _options?: Configuration): Promise<MessageEventsOut> {
        const result = this.api.v1Events(limit, iterator, eventTypes, channels, after, _options);
        return result.toPromise();
    }


}



import { ObservableHealthApi } from './ObservableAPI';

import { HealthApiRequestFactory, HealthApiResponseProcessor} from "../apis/HealthApi";
export class PromiseHealthApi {
    private api: ObservableHealthApi

    public constructor(
        configuration: Configuration,
        requestFactory?: HealthApiRequestFactory,
        responseProcessor?: HealthApiResponseProcessor
    ) {
        this.api = new ObservableHealthApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Verify the API server is up and running.
     * Health
     */
    public v1HealthGetWithHttpInfo(_options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1HealthGetWithHttpInfo(_options);
        return result.toPromise();
    }

    /**
     * Verify the API server is up and running.
     * Health
     */
    public v1HealthGet(_options?: Configuration): Promise<void> {
        const result = this.api.v1HealthGet(_options);
        return result.toPromise();
    }


}



import { ObservableInboundApi } from './ObservableAPI';

import { InboundApiRequestFactory, InboundApiResponseProcessor} from "../apis/InboundApi";
export class PromiseInboundApi {
    private api: ObservableInboundApi

    public constructor(
        configuration: Configuration,
        requestFactory?: InboundApiRequestFactory,
        responseProcessor?: InboundApiResponseProcessor
    ) {
        this.api = new ObservableInboundApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Handles a raw inbound webhook for the application.
     * Handle Inbound
     * @param appId The app\&#39;s ID or UID
     * @param inboundToken
     * @param body
     * @param [eventType] The event type\&#39;s name
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1InboundMsgWithHttpInfo(appId: string, inboundToken: string, body: string, eventType?: string, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<MessageOut>> {
        const result = this.api.v1InboundMsgWithHttpInfo(appId, inboundToken, body, eventType, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Handles a raw inbound webhook for the application.
     * Handle Inbound
     * @param appId The app\&#39;s ID or UID
     * @param inboundToken
     * @param body
     * @param [eventType] The event type\&#39;s name
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1InboundMsg(appId: string, inboundToken: string, body: string, eventType?: string, idempotencyKey?: string, _options?: Configuration): Promise<MessageOut> {
        const result = this.api.v1InboundMsg(appId, inboundToken, body, eventType, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Invalidates the previous inbound url (if one exists), producing a new inbound URL for this app
     * Rotate Url
     * @param appId The app\&#39;s ID or UID
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1InboundRotateUrlWithHttpInfo(appId: string, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<RotatedUrlOut>> {
        const result = this.api.v1InboundRotateUrlWithHttpInfo(appId, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Invalidates the previous inbound url (if one exists), producing a new inbound URL for this app
     * Rotate Url
     * @param appId The app\&#39;s ID or UID
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1InboundRotateUrl(appId: string, idempotencyKey?: string, _options?: Configuration): Promise<RotatedUrlOut> {
        const result = this.api.v1InboundRotateUrl(appId, idempotencyKey, _options);
        return result.toPromise();
    }


}



import { ObservableIntegrationApi } from './ObservableAPI';

import { IntegrationApiRequestFactory, IntegrationApiResponseProcessor} from "../apis/IntegrationApi";
export class PromiseIntegrationApi {
    private api: ObservableIntegrationApi

    public constructor(
        configuration: Configuration,
        requestFactory?: IntegrationApiRequestFactory,
        responseProcessor?: IntegrationApiResponseProcessor
    ) {
        this.api = new ObservableIntegrationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create an integration.
     * Create Integration
     * @param appId The app\&#39;s ID or UID
     * @param integrationIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1IntegrationCreateWithHttpInfo(appId: string, integrationIn: IntegrationIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<IntegrationOut>> {
        const result = this.api.v1IntegrationCreateWithHttpInfo(appId, integrationIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Create an integration.
     * Create Integration
     * @param appId The app\&#39;s ID or UID
     * @param integrationIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1IntegrationCreate(appId: string, integrationIn: IntegrationIn, idempotencyKey?: string, _options?: Configuration): Promise<IntegrationOut> {
        const result = this.api.v1IntegrationCreate(appId, integrationIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Delete an integration.
     * Delete Integration
     * @param appId The app\&#39;s ID or UID
     * @param integId The integ\&#39;s ID
     */
    public v1IntegrationDeleteWithHttpInfo(appId: string, integId: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1IntegrationDeleteWithHttpInfo(appId, integId, _options);
        return result.toPromise();
    }

    /**
     * Delete an integration.
     * Delete Integration
     * @param appId The app\&#39;s ID or UID
     * @param integId The integ\&#39;s ID
     */
    public v1IntegrationDelete(appId: string, integId: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1IntegrationDelete(appId, integId, _options);
        return result.toPromise();
    }

    /**
     * Get an integration.
     * Get Integration
     * @param appId The app\&#39;s ID or UID
     * @param integId The integ\&#39;s ID
     */
    public v1IntegrationGetWithHttpInfo(appId: string, integId: string, _options?: Configuration): Promise<HttpInfo<IntegrationOut>> {
        const result = this.api.v1IntegrationGetWithHttpInfo(appId, integId, _options);
        return result.toPromise();
    }

    /**
     * Get an integration.
     * Get Integration
     * @param appId The app\&#39;s ID or UID
     * @param integId The integ\&#39;s ID
     */
    public v1IntegrationGet(appId: string, integId: string, _options?: Configuration): Promise<IntegrationOut> {
        const result = this.api.v1IntegrationGet(appId, integId, _options);
        return result.toPromise();
    }

    /**
     * Get an integration\'s key.
     * Get Integration Key
     * @param appId The app\&#39;s ID or UID
     * @param integId The integ\&#39;s ID
     */
    public v1IntegrationGetKeyWithHttpInfo(appId: string, integId: string, _options?: Configuration): Promise<HttpInfo<IntegrationKeyOut>> {
        const result = this.api.v1IntegrationGetKeyWithHttpInfo(appId, integId, _options);
        return result.toPromise();
    }

    /**
     * Get an integration\'s key.
     * Get Integration Key
     * @param appId The app\&#39;s ID or UID
     * @param integId The integ\&#39;s ID
     */
    public v1IntegrationGetKey(appId: string, integId: string, _options?: Configuration): Promise<IntegrationKeyOut> {
        const result = this.api.v1IntegrationGetKey(appId, integId, _options);
        return result.toPromise();
    }

    /**
     * List the application\'s integrations.
     * List Integrations
     * @param appId The app\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1IntegrationListWithHttpInfo(appId: string, limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<HttpInfo<ListResponseIntegrationOut>> {
        const result = this.api.v1IntegrationListWithHttpInfo(appId, limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * List the application\'s integrations.
     * List Integrations
     * @param appId The app\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1IntegrationList(appId: string, limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<ListResponseIntegrationOut> {
        const result = this.api.v1IntegrationList(appId, limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * Rotate the integration\'s key. The previous key will be immediately revoked.
     * Rotate Integration Key
     * @param appId The app\&#39;s ID or UID
     * @param integId The integ\&#39;s ID
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1IntegrationRotateKeyWithHttpInfo(appId: string, integId: string, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<IntegrationKeyOut>> {
        const result = this.api.v1IntegrationRotateKeyWithHttpInfo(appId, integId, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Rotate the integration\'s key. The previous key will be immediately revoked.
     * Rotate Integration Key
     * @param appId The app\&#39;s ID or UID
     * @param integId The integ\&#39;s ID
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1IntegrationRotateKey(appId: string, integId: string, idempotencyKey?: string, _options?: Configuration): Promise<IntegrationKeyOut> {
        const result = this.api.v1IntegrationRotateKey(appId, integId, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Update an integration.
     * Update Integration
     * @param appId The app\&#39;s ID or UID
     * @param integId The integ\&#39;s ID
     * @param integrationUpdate
     */
    public v1IntegrationUpdateWithHttpInfo(appId: string, integId: string, integrationUpdate: IntegrationUpdate, _options?: Configuration): Promise<HttpInfo<IntegrationOut>> {
        const result = this.api.v1IntegrationUpdateWithHttpInfo(appId, integId, integrationUpdate, _options);
        return result.toPromise();
    }

    /**
     * Update an integration.
     * Update Integration
     * @param appId The app\&#39;s ID or UID
     * @param integId The integ\&#39;s ID
     * @param integrationUpdate
     */
    public v1IntegrationUpdate(appId: string, integId: string, integrationUpdate: IntegrationUpdate, _options?: Configuration): Promise<IntegrationOut> {
        const result = this.api.v1IntegrationUpdate(appId, integId, integrationUpdate, _options);
        return result.toPromise();
    }


}



import { ObservableMessageApi } from './ObservableAPI';

import { MessageApiRequestFactory, MessageApiResponseProcessor} from "../apis/MessageApi";
export class PromiseMessageApi {
    private api: ObservableMessageApi

    public constructor(
        configuration: Configuration,
        requestFactory?: MessageApiRequestFactory,
        responseProcessor?: MessageApiResponseProcessor
    ) {
        this.api = new ObservableMessageApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Creates and sends a message to the specified endpoint. The message attempt and response from the endpoint is returned. FIXME: use MessageIn for expediency, even though the `application` parameter is unused. Since this endpoint isn\'t publicly documented anyway, it should be fine
     * Create Message Attempt For Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param messageIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public createMessageAttemptForEndpointWithHttpInfo(appId: string, endpointId: string, messageIn: MessageIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<MessageAttemptOut>> {
        const result = this.api.createMessageAttemptForEndpointWithHttpInfo(appId, endpointId, messageIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Creates and sends a message to the specified endpoint. The message attempt and response from the endpoint is returned. FIXME: use MessageIn for expediency, even though the `application` parameter is unused. Since this endpoint isn\'t publicly documented anyway, it should be fine
     * Create Message Attempt For Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param messageIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public createMessageAttemptForEndpoint(appId: string, endpointId: string, messageIn: MessageIn, idempotencyKey?: string, _options?: Configuration): Promise<MessageAttemptOut> {
        const result = this.api.createMessageAttemptForEndpoint(appId, endpointId, messageIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Creates a new message and dispatches it to all of the application\'s endpoints.  The `eventId` is an optional custom unique ID. It\'s verified to be unique only up to a day, after that no verification will be made. If a message with the same `eventId` already exists for the application, a 409 conflict error will be returned.  The `eventType` indicates the type and schema of the event. All messages of a certain `eventType` are expected to have the same schema. Endpoints can choose to only listen to specific event types. Messages can also have `channels`, which similar to event types let endpoints filter by them. Unlike event types, messages can have multiple channels, and channels don\'t imply a specific message content or schema.  The `payload` property is the webhook\'s body (the actual webhook message). Svix supports payload sizes of up to ~350kb, though it\'s generally a good idea to keep webhook payloads small, probably no larger than 40kb.
     * Create Message
     * @param appId The app\&#39;s ID or UID
     * @param messageIn
     * @param [withContent] When &#x60;true&#x60; message payloads are included in the response
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1MessageCreateWithHttpInfo(appId: string, messageIn: MessageIn, withContent?: boolean, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<MessageOut>> {
        const result = this.api.v1MessageCreateWithHttpInfo(appId, messageIn, withContent, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Creates a new message and dispatches it to all of the application\'s endpoints.  The `eventId` is an optional custom unique ID. It\'s verified to be unique only up to a day, after that no verification will be made. If a message with the same `eventId` already exists for the application, a 409 conflict error will be returned.  The `eventType` indicates the type and schema of the event. All messages of a certain `eventType` are expected to have the same schema. Endpoints can choose to only listen to specific event types. Messages can also have `channels`, which similar to event types let endpoints filter by them. Unlike event types, messages can have multiple channels, and channels don\'t imply a specific message content or schema.  The `payload` property is the webhook\'s body (the actual webhook message). Svix supports payload sizes of up to ~350kb, though it\'s generally a good idea to keep webhook payloads small, probably no larger than 40kb.
     * Create Message
     * @param appId The app\&#39;s ID or UID
     * @param messageIn
     * @param [withContent] When &#x60;true&#x60; message payloads are included in the response
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1MessageCreate(appId: string, messageIn: MessageIn, withContent?: boolean, idempotencyKey?: string, _options?: Configuration): Promise<MessageOut> {
        const result = this.api.v1MessageCreate(appId, messageIn, withContent, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Reads the stream of created messages for an application
     * Message Events
     * @param appId The app\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [eventTypes] Filter response based on the event type
     * @param [channels] Filter response based on the event type
     * @param [after]
     */
    public v1MessageEventsWithHttpInfo(appId: string, limit?: number, iterator?: string, eventTypes?: Array<string>, channels?: Array<string>, after?: Date, _options?: Configuration): Promise<HttpInfo<MessageEventsOut>> {
        const result = this.api.v1MessageEventsWithHttpInfo(appId, limit, iterator, eventTypes, channels, after, _options);
        return result.toPromise();
    }

    /**
     * Reads the stream of created messages for an application
     * Message Events
     * @param appId The app\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [eventTypes] Filter response based on the event type
     * @param [channels] Filter response based on the event type
     * @param [after]
     */
    public v1MessageEvents(appId: string, limit?: number, iterator?: string, eventTypes?: Array<string>, channels?: Array<string>, after?: Date, _options?: Configuration): Promise<MessageEventsOut> {
        const result = this.api.v1MessageEvents(appId, limit, iterator, eventTypes, channels, after, _options);
        return result.toPromise();
    }

    /**
     * Reads the stream of created messages for an application, but using server-managed iterator tracking.
     * Message Events Subscription
     * @param appId The app\&#39;s ID or UID
     * @param subscriptionId The esub\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [eventTypes] Filter response based on the event type
     * @param [channels] Filter response based on the event type
     * @param [after]
     */
    public v1MessageEventsSubscriptionWithHttpInfo(appId: string, subscriptionId: string, limit?: number, iterator?: string, eventTypes?: Array<string>, channels?: Array<string>, after?: Date, _options?: Configuration): Promise<HttpInfo<MessageEventsOut>> {
        const result = this.api.v1MessageEventsSubscriptionWithHttpInfo(appId, subscriptionId, limit, iterator, eventTypes, channels, after, _options);
        return result.toPromise();
    }

    /**
     * Reads the stream of created messages for an application, but using server-managed iterator tracking.
     * Message Events Subscription
     * @param appId The app\&#39;s ID or UID
     * @param subscriptionId The esub\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [eventTypes] Filter response based on the event type
     * @param [channels] Filter response based on the event type
     * @param [after]
     */
    public v1MessageEventsSubscription(appId: string, subscriptionId: string, limit?: number, iterator?: string, eventTypes?: Array<string>, channels?: Array<string>, after?: Date, _options?: Configuration): Promise<MessageEventsOut> {
        const result = this.api.v1MessageEventsSubscription(appId, subscriptionId, limit, iterator, eventTypes, channels, after, _options);
        return result.toPromise();
    }

    /**
     * Creates an auth token that can be used with the `v1.message.events-subscription` endpoint
     * Message Events Create Token
     * @param appId The app\&#39;s ID or UID
     * @param subscriptionId The esub\&#39;s ID or UID
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1MessageEventsSubscriptionCreateTokenWithHttpInfo(appId: string, subscriptionId: string, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<MessageSubscriberAuthTokenOut>> {
        const result = this.api.v1MessageEventsSubscriptionCreateTokenWithHttpInfo(appId, subscriptionId, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Creates an auth token that can be used with the `v1.message.events-subscription` endpoint
     * Message Events Create Token
     * @param appId The app\&#39;s ID or UID
     * @param subscriptionId The esub\&#39;s ID or UID
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1MessageEventsSubscriptionCreateToken(appId: string, subscriptionId: string, idempotencyKey?: string, _options?: Configuration): Promise<MessageSubscriberAuthTokenOut> {
        const result = this.api.v1MessageEventsSubscriptionCreateToken(appId, subscriptionId, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Delete the given message\'s payload. Useful in cases when a message was accidentally sent with sensitive content.  The message can\'t be replayed or resent once its payload has been deleted or expired.
     * Delete message payload
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     */
    public v1MessageExpungeContentWithHttpInfo(appId: string, msgId: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1MessageExpungeContentWithHttpInfo(appId, msgId, _options);
        return result.toPromise();
    }

    /**
     * Delete the given message\'s payload. Useful in cases when a message was accidentally sent with sensitive content.  The message can\'t be replayed or resent once its payload has been deleted or expired.
     * Delete message payload
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     */
    public v1MessageExpungeContent(appId: string, msgId: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1MessageExpungeContent(appId, msgId, _options);
        return result.toPromise();
    }

    /**
     * Get a message by its ID or eventID.
     * Get Message
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param [withContent] When &#x60;true&#x60; message payloads are included in the response
     */
    public v1MessageGetWithHttpInfo(appId: string, msgId: string, withContent?: boolean, _options?: Configuration): Promise<HttpInfo<MessageOut>> {
        const result = this.api.v1MessageGetWithHttpInfo(appId, msgId, withContent, _options);
        return result.toPromise();
    }

    /**
     * Get a message by its ID or eventID.
     * Get Message
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param [withContent] When &#x60;true&#x60; message payloads are included in the response
     */
    public v1MessageGet(appId: string, msgId: string, withContent?: boolean, _options?: Configuration): Promise<MessageOut> {
        const result = this.api.v1MessageGet(appId, msgId, withContent, _options);
        return result.toPromise();
    }

    /**
     * Get a message raw payload by its ID or eventID.
     * Get Raw Message Payload
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     */
    public v1MessageGetRawPayloadWithHttpInfo(appId: string, msgId: string, _options?: Configuration): Promise<HttpInfo<MessageRawPayloadOut>> {
        const result = this.api.v1MessageGetRawPayloadWithHttpInfo(appId, msgId, _options);
        return result.toPromise();
    }

    /**
     * Get a message raw payload by its ID or eventID.
     * Get Raw Message Payload
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     */
    public v1MessageGetRawPayload(appId: string, msgId: string, _options?: Configuration): Promise<MessageRawPayloadOut> {
        const result = this.api.v1MessageGetRawPayload(appId, msgId, _options);
        return result.toPromise();
    }

    /**
     * List all of the application\'s messages.  The `before` and `after` parameters let you filter all items created before or after a certain date. These can be used alongside an iterator to paginate over results within a certain window.  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Messages
     * @param appId The app\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [channel] Filter response based on the channel
     * @param [before] Only include items created before a certain date
     * @param [after] Only include items created after a certain date
     * @param [withContent] When &#x60;true&#x60; message payloads are included in the response
     * @param [tag] Filter messages matching the provided tag
     * @param [eventTypes] Filter response based on the event type
     */
    public v1MessageListWithHttpInfo(appId: string, limit?: number, iterator?: string, channel?: string, before?: Date, after?: Date, withContent?: boolean, tag?: string, eventTypes?: Array<string>, _options?: Configuration): Promise<HttpInfo<ListResponseMessageOut>> {
        const result = this.api.v1MessageListWithHttpInfo(appId, limit, iterator, channel, before, after, withContent, tag, eventTypes, _options);
        return result.toPromise();
    }

    /**
     * List all of the application\'s messages.  The `before` and `after` parameters let you filter all items created before or after a certain date. These can be used alongside an iterator to paginate over results within a certain window.  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Messages
     * @param appId The app\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [channel] Filter response based on the channel
     * @param [before] Only include items created before a certain date
     * @param [after] Only include items created after a certain date
     * @param [withContent] When &#x60;true&#x60; message payloads are included in the response
     * @param [tag] Filter messages matching the provided tag
     * @param [eventTypes] Filter response based on the event type
     */
    public v1MessageList(appId: string, limit?: number, iterator?: string, channel?: string, before?: Date, after?: Date, withContent?: boolean, tag?: string, eventTypes?: Array<string>, _options?: Configuration): Promise<ListResponseMessageOut> {
        const result = this.api.v1MessageList(appId, limit, iterator, channel, before, after, withContent, tag, eventTypes, _options);
        return result.toPromise();
    }


}



import { ObservableMessageAttemptApi } from './ObservableAPI';

import { MessageAttemptApiRequestFactory, MessageAttemptApiResponseProcessor} from "../apis/MessageAttemptApi";
export class PromiseMessageAttemptApi {
    private api: ObservableMessageAttemptApi

    public constructor(
        configuration: Configuration,
        requestFactory?: MessageAttemptApiRequestFactory,
        responseProcessor?: MessageAttemptApiResponseProcessor
    ) {
        this.api = new ObservableMessageAttemptApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Deletes the given attempt\'s response body. Useful when an endpoint accidentally returned sensitive content.
     * Delete attempt response body
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param attemptId The attempt\&#39;s ID
     */
    public v1MessageAttemptExpungeContentWithHttpInfo(appId: string, msgId: string, attemptId: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1MessageAttemptExpungeContentWithHttpInfo(appId, msgId, attemptId, _options);
        return result.toPromise();
    }

    /**
     * Deletes the given attempt\'s response body. Useful when an endpoint accidentally returned sensitive content.
     * Delete attempt response body
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param attemptId The attempt\&#39;s ID
     */
    public v1MessageAttemptExpungeContent(appId: string, msgId: string, attemptId: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1MessageAttemptExpungeContent(appId, msgId, attemptId, _options);
        return result.toPromise();
    }

    /**
     * `msg_id`: Use a message id or a message `eventId`
     * Get Attempt
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param attemptId The attempt\&#39;s ID
     */
    public v1MessageAttemptGetWithHttpInfo(appId: string, msgId: string, attemptId: string, _options?: Configuration): Promise<HttpInfo<MessageAttemptOut>> {
        const result = this.api.v1MessageAttemptGetWithHttpInfo(appId, msgId, attemptId, _options);
        return result.toPromise();
    }

    /**
     * `msg_id`: Use a message id or a message `eventId`
     * Get Attempt
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param attemptId The attempt\&#39;s ID
     */
    public v1MessageAttemptGet(appId: string, msgId: string, attemptId: string, _options?: Configuration): Promise<MessageAttemptOut> {
        const result = this.api.v1MessageAttemptGet(appId, msgId, attemptId, _options);
        return result.toPromise();
    }

    /**
     * Calculate and return headers used on a given message attempt
     * Get Attempt Headers
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param attemptId The attempt\&#39;s ID
     */
    public v1MessageAttemptGetHeadersWithHttpInfo(appId: string, msgId: string, attemptId: string, _options?: Configuration): Promise<HttpInfo<MessageAttemptHeadersOut>> {
        const result = this.api.v1MessageAttemptGetHeadersWithHttpInfo(appId, msgId, attemptId, _options);
        return result.toPromise();
    }

    /**
     * Calculate and return headers used on a given message attempt
     * Get Attempt Headers
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param attemptId The attempt\&#39;s ID
     */
    public v1MessageAttemptGetHeaders(appId: string, msgId: string, attemptId: string, _options?: Configuration): Promise<MessageAttemptHeadersOut> {
        const result = this.api.v1MessageAttemptGetHeaders(appId, msgId, attemptId, _options);
        return result.toPromise();
    }

    /**
     * List endpoints attempted by a given message. Additionally includes metadata about the latest message attempt. By default, endpoints are listed in ascending order by ID.
     * List Attempted Destinations
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     */
    public v1MessageAttemptListAttemptedDestinationsWithHttpInfo(appId: string, msgId: string, limit?: number, iterator?: string, _options?: Configuration): Promise<HttpInfo<ListResponseMessageEndpointOut>> {
        const result = this.api.v1MessageAttemptListAttemptedDestinationsWithHttpInfo(appId, msgId, limit, iterator, _options);
        return result.toPromise();
    }

    /**
     * List endpoints attempted by a given message. Additionally includes metadata about the latest message attempt. By default, endpoints are listed in ascending order by ID.
     * List Attempted Destinations
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     */
    public v1MessageAttemptListAttemptedDestinations(appId: string, msgId: string, limit?: number, iterator?: string, _options?: Configuration): Promise<ListResponseMessageEndpointOut> {
        const result = this.api.v1MessageAttemptListAttemptedDestinations(appId, msgId, limit, iterator, _options);
        return result.toPromise();
    }

    /**
     * List messages for a particular endpoint. Additionally includes metadata about the latest message attempt.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Attempted Messages
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [channel] Filter response based on the channel
     * @param [tag] Filter response based on the message tags
     * @param [status] Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
     * @param [before] Only include items created before a certain date
     * @param [after] Only include items created after a certain date
     * @param [withContent] When &#x60;true&#x60; message payloads are included in the response
     * @param [eventTypes] Filter response based on the event type
     */
    public v1MessageAttemptListAttemptedMessagesWithHttpInfo(appId: string, endpointId: string, limit?: number, iterator?: string, channel?: string, tag?: string, status?: MessageStatus, before?: Date, after?: Date, withContent?: boolean, eventTypes?: Array<string>, _options?: Configuration): Promise<HttpInfo<ListResponseEndpointMessageOut>> {
        const result = this.api.v1MessageAttemptListAttemptedMessagesWithHttpInfo(appId, endpointId, limit, iterator, channel, tag, status, before, after, withContent, eventTypes, _options);
        return result.toPromise();
    }

    /**
     * List messages for a particular endpoint. Additionally includes metadata about the latest message attempt.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Attempted Messages
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [channel] Filter response based on the channel
     * @param [tag] Filter response based on the message tags
     * @param [status] Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
     * @param [before] Only include items created before a certain date
     * @param [after] Only include items created after a certain date
     * @param [withContent] When &#x60;true&#x60; message payloads are included in the response
     * @param [eventTypes] Filter response based on the event type
     */
    public v1MessageAttemptListAttemptedMessages(appId: string, endpointId: string, limit?: number, iterator?: string, channel?: string, tag?: string, status?: MessageStatus, before?: Date, after?: Date, withContent?: boolean, eventTypes?: Array<string>, _options?: Configuration): Promise<ListResponseEndpointMessageOut> {
        const result = this.api.v1MessageAttemptListAttemptedMessages(appId, endpointId, limit, iterator, channel, tag, status, before, after, withContent, eventTypes, _options);
        return result.toPromise();
    }

    /**
     * List attempts by endpoint id  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Attempts By Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [status] Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
     * @param [statusCodeClass] Filter response based on the HTTP status code
     * @param [channel] Filter response based on the channel
     * @param [tag] Filter response based on the tag
     * @param [before] Only include items created before a certain date
     * @param [after] Only include items created after a certain date
     * @param [withContent] When &#x60;true&#x60; attempt content is included in the response
     * @param [withMsg] When &#x60;true&#x60;, the message information is included in the response
     * @param [eventTypes] Filter response based on the event type
     */
    public v1MessageAttemptListByEndpointWithHttpInfo(appId: string, endpointId: string, limit?: number, iterator?: string, status?: MessageStatus, statusCodeClass?: StatusCodeClass, channel?: string, tag?: string, before?: Date, after?: Date, withContent?: boolean, withMsg?: boolean, eventTypes?: Array<string>, _options?: Configuration): Promise<HttpInfo<ListResponseMessageAttemptOut>> {
        const result = this.api.v1MessageAttemptListByEndpointWithHttpInfo(appId, endpointId, limit, iterator, status, statusCodeClass, channel, tag, before, after, withContent, withMsg, eventTypes, _options);
        return result.toPromise();
    }

    /**
     * List attempts by endpoint id  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Attempts By Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [status] Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
     * @param [statusCodeClass] Filter response based on the HTTP status code
     * @param [channel] Filter response based on the channel
     * @param [tag] Filter response based on the tag
     * @param [before] Only include items created before a certain date
     * @param [after] Only include items created after a certain date
     * @param [withContent] When &#x60;true&#x60; attempt content is included in the response
     * @param [withMsg] When &#x60;true&#x60;, the message information is included in the response
     * @param [eventTypes] Filter response based on the event type
     */
    public v1MessageAttemptListByEndpoint(appId: string, endpointId: string, limit?: number, iterator?: string, status?: MessageStatus, statusCodeClass?: StatusCodeClass, channel?: string, tag?: string, before?: Date, after?: Date, withContent?: boolean, withMsg?: boolean, eventTypes?: Array<string>, _options?: Configuration): Promise<ListResponseMessageAttemptOut> {
        const result = this.api.v1MessageAttemptListByEndpoint(appId, endpointId, limit, iterator, status, statusCodeClass, channel, tag, before, after, withContent, withMsg, eventTypes, _options);
        return result.toPromise();
    }

    /**
     * DEPRECATED: please use list_attempts with endpoint_id as a query parameter instead.  List the message attempts for a particular endpoint.  Returning the endpoint.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Attempts For Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [channel] Filter response based on the channel
     * @param [tag] Filter response based on the tag
     * @param [status] Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
     * @param [before] Only include items created before a certain date
     * @param [after] Only include items created after a certain date
     * @param [eventTypes] Filter response based on the event type
     */
    public v1MessageAttemptListByEndpointDeprecatedWithHttpInfo(appId: string, msgId: string, endpointId: string, limit?: number, iterator?: string, channel?: string, tag?: string, status?: MessageStatus, before?: Date, after?: Date, eventTypes?: Array<string>, _options?: Configuration): Promise<HttpInfo<ListResponseMessageAttemptEndpointOut>> {
        const result = this.api.v1MessageAttemptListByEndpointDeprecatedWithHttpInfo(appId, msgId, endpointId, limit, iterator, channel, tag, status, before, after, eventTypes, _options);
        return result.toPromise();
    }

    /**
     * DEPRECATED: please use list_attempts with endpoint_id as a query parameter instead.  List the message attempts for a particular endpoint.  Returning the endpoint.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Attempts For Endpoint
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [channel] Filter response based on the channel
     * @param [tag] Filter response based on the tag
     * @param [status] Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
     * @param [before] Only include items created before a certain date
     * @param [after] Only include items created after a certain date
     * @param [eventTypes] Filter response based on the event type
     */
    public v1MessageAttemptListByEndpointDeprecated(appId: string, msgId: string, endpointId: string, limit?: number, iterator?: string, channel?: string, tag?: string, status?: MessageStatus, before?: Date, after?: Date, eventTypes?: Array<string>, _options?: Configuration): Promise<ListResponseMessageAttemptEndpointOut> {
        const result = this.api.v1MessageAttemptListByEndpointDeprecated(appId, msgId, endpointId, limit, iterator, channel, tag, status, before, after, eventTypes, _options);
        return result.toPromise();
    }

    /**
     * List attempts by message id  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Attempts By Msg
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [status] Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
     * @param [statusCodeClass] Filter response based on the HTTP status code
     * @param [channel] Filter response based on the channel
     * @param [tag] Filter response based on the tag
     * @param [endpointId] Filter the attempts based on the attempted endpoint
     * @param [before] Only include items created before a certain date
     * @param [after] Only include items created after a certain date
     * @param [withContent] When &#x60;true&#x60; attempt content is included in the response
     * @param [eventTypes] Filter response based on the event type
     */
    public v1MessageAttemptListByMsgWithHttpInfo(appId: string, msgId: string, limit?: number, iterator?: string, status?: MessageStatus, statusCodeClass?: StatusCodeClass, channel?: string, tag?: string, endpointId?: string, before?: Date, after?: Date, withContent?: boolean, eventTypes?: Array<string>, _options?: Configuration): Promise<HttpInfo<ListResponseMessageAttemptOut>> {
        const result = this.api.v1MessageAttemptListByMsgWithHttpInfo(appId, msgId, limit, iterator, status, statusCodeClass, channel, tag, endpointId, before, after, withContent, eventTypes, _options);
        return result.toPromise();
    }

    /**
     * List attempts by message id  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Attempts By Msg
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [status] Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
     * @param [statusCodeClass] Filter response based on the HTTP status code
     * @param [channel] Filter response based on the channel
     * @param [tag] Filter response based on the tag
     * @param [endpointId] Filter the attempts based on the attempted endpoint
     * @param [before] Only include items created before a certain date
     * @param [after] Only include items created after a certain date
     * @param [withContent] When &#x60;true&#x60; attempt content is included in the response
     * @param [eventTypes] Filter response based on the event type
     */
    public v1MessageAttemptListByMsg(appId: string, msgId: string, limit?: number, iterator?: string, status?: MessageStatus, statusCodeClass?: StatusCodeClass, channel?: string, tag?: string, endpointId?: string, before?: Date, after?: Date, withContent?: boolean, eventTypes?: Array<string>, _options?: Configuration): Promise<ListResponseMessageAttemptOut> {
        const result = this.api.v1MessageAttemptListByMsg(appId, msgId, limit, iterator, status, statusCodeClass, channel, tag, endpointId, before, after, withContent, eventTypes, _options);
        return result.toPromise();
    }

    /**
     * Deprecated: Please use \"List Attempts by Endpoint\" and \"List Attempts by Msg\" instead.  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate.  `msg_id`: Use a message id or a message `eventId`
     * List Attempts
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [endpointId] Filter the attempts based on the attempted endpoint
     * @param [channel] Filter response based on the channel
     * @param [tag] Filter response based on the tag
     * @param [status] Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
     * @param [before] Only include items created before a certain date
     * @param [after] Only include items created after a certain date
     * @param [statusCodeClass] Filter response based on the HTTP status code
     * @param [eventTypes] Filter response based on the event type
     */
    public v1MessageAttemptListByMsgDeprecatedWithHttpInfo(appId: string, msgId: string, limit?: number, iterator?: string, endpointId?: string, channel?: string, tag?: string, status?: MessageStatus, before?: Date, after?: Date, statusCodeClass?: StatusCodeClass, eventTypes?: Array<string>, _options?: Configuration): Promise<HttpInfo<ListResponseMessageAttemptOut>> {
        const result = this.api.v1MessageAttemptListByMsgDeprecatedWithHttpInfo(appId, msgId, limit, iterator, endpointId, channel, tag, status, before, after, statusCodeClass, eventTypes, _options);
        return result.toPromise();
    }

    /**
     * Deprecated: Please use \"List Attempts by Endpoint\" and \"List Attempts by Msg\" instead.  Note that by default this endpoint is limited to retrieving 90 days\' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate.  `msg_id`: Use a message id or a message `eventId`
     * List Attempts
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [endpointId] Filter the attempts based on the attempted endpoint
     * @param [channel] Filter response based on the channel
     * @param [tag] Filter response based on the tag
     * @param [status] Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
     * @param [before] Only include items created before a certain date
     * @param [after] Only include items created after a certain date
     * @param [statusCodeClass] Filter response based on the HTTP status code
     * @param [eventTypes] Filter response based on the event type
     */
    public v1MessageAttemptListByMsgDeprecated(appId: string, msgId: string, limit?: number, iterator?: string, endpointId?: string, channel?: string, tag?: string, status?: MessageStatus, before?: Date, after?: Date, statusCodeClass?: StatusCodeClass, eventTypes?: Array<string>, _options?: Configuration): Promise<ListResponseMessageAttemptOut> {
        const result = this.api.v1MessageAttemptListByMsgDeprecated(appId, msgId, limit, iterator, endpointId, channel, tag, status, before, after, statusCodeClass, eventTypes, _options);
        return result.toPromise();
    }

    /**
     * Resend a message to the specified endpoint.
     * Resend Webhook
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1MessageAttemptResendWithHttpInfo(appId: string, msgId: string, endpointId: string, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1MessageAttemptResendWithHttpInfo(appId, msgId, endpointId, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Resend a message to the specified endpoint.
     * Resend Webhook
     * @param appId The app\&#39;s ID or UID
     * @param msgId The msg\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1MessageAttemptResend(appId: string, msgId: string, endpointId: string, idempotencyKey?: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1MessageAttemptResend(appId, msgId, endpointId, idempotencyKey, _options);
        return result.toPromise();
    }


}



import { ObservableStatisticsApi } from './ObservableAPI';

import { StatisticsApiRequestFactory, StatisticsApiResponseProcessor} from "../apis/StatisticsApi";
export class PromiseStatisticsApi {
    private api: ObservableStatisticsApi

    public constructor(
        configuration: Configuration,
        requestFactory?: StatisticsApiRequestFactory,
        responseProcessor?: StatisticsApiResponseProcessor
    ) {
        this.api = new ObservableStatisticsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Creates a background task to calculate the message destinations for all applications in the environment.  Note that this endpoint is asynchronous. You will need to poll the `Get Background Task` endpoint to retrieve the results of the operation.
     * Aggregate App Stats
     * @param appUsageStatsIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1StatisticsAggregateAppStatsWithHttpInfo(appUsageStatsIn: AppUsageStatsIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<AppUsageStatsOut>> {
        const result = this.api.v1StatisticsAggregateAppStatsWithHttpInfo(appUsageStatsIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Creates a background task to calculate the message destinations for all applications in the environment.  Note that this endpoint is asynchronous. You will need to poll the `Get Background Task` endpoint to retrieve the results of the operation.
     * Aggregate App Stats
     * @param appUsageStatsIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1StatisticsAggregateAppStats(appUsageStatsIn: AppUsageStatsIn, idempotencyKey?: string, _options?: Configuration): Promise<AppUsageStatsOut> {
        const result = this.api.v1StatisticsAggregateAppStats(appUsageStatsIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Creates a background task to calculate the listed event types for all apps in the organization.  Note that this endpoint is asynchronous. You will need to poll the `Get Background Task` endpoint to retrieve the results of the operation.
     * Aggregate Event Types
     */
    public v1StatisticsAggregateEventTypesWithHttpInfo(_options?: Configuration): Promise<HttpInfo<AggregateEventTypesOut>> {
        const result = this.api.v1StatisticsAggregateEventTypesWithHttpInfo(_options);
        return result.toPromise();
    }

    /**
     * Creates a background task to calculate the listed event types for all apps in the organization.  Note that this endpoint is asynchronous. You will need to poll the `Get Background Task` endpoint to retrieve the results of the operation.
     * Aggregate Event Types
     */
    public v1StatisticsAggregateEventTypes(_options?: Configuration): Promise<AggregateEventTypesOut> {
        const result = this.api.v1StatisticsAggregateEventTypes(_options);
        return result.toPromise();
    }

    /**
     * Returns application-level statistics on message attempts
     * Get App Attempt Stats
     * @param appId The app\&#39;s ID or UID
     * @param [startDate] Filter the range to data starting from this date
     * @param [endDate] Filter the range to data ending by this date
     */
    public v1StatsAppAttemptsWithHttpInfo(appId: string, startDate?: Date, endDate?: Date, _options?: Configuration): Promise<HttpInfo<AttemptStatisticsResponse>> {
        const result = this.api.v1StatsAppAttemptsWithHttpInfo(appId, startDate, endDate, _options);
        return result.toPromise();
    }

    /**
     * Returns application-level statistics on message attempts
     * Get App Attempt Stats
     * @param appId The app\&#39;s ID or UID
     * @param [startDate] Filter the range to data starting from this date
     * @param [endDate] Filter the range to data ending by this date
     */
    public v1StatsAppAttempts(appId: string, startDate?: Date, endDate?: Date, _options?: Configuration): Promise<AttemptStatisticsResponse> {
        const result = this.api.v1StatsAppAttempts(appId, startDate, endDate, _options);
        return result.toPromise();
    }

    /**
     * Returns endpoint-level statistics on message attempts
     * Get Ep Stats
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param [startDate] Filter the range to data starting from this date
     * @param [endDate] Filter the range to data ending by this date
     */
    public v1StatsEndpointAttemptsWithHttpInfo(appId: string, endpointId: string, startDate?: Date, endDate?: Date, _options?: Configuration): Promise<HttpInfo<AttemptStatisticsResponse>> {
        const result = this.api.v1StatsEndpointAttemptsWithHttpInfo(appId, endpointId, startDate, endDate, _options);
        return result.toPromise();
    }

    /**
     * Returns endpoint-level statistics on message attempts
     * Get Ep Stats
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param [startDate] Filter the range to data starting from this date
     * @param [endDate] Filter the range to data ending by this date
     */
    public v1StatsEndpointAttempts(appId: string, endpointId: string, startDate?: Date, endDate?: Date, _options?: Configuration): Promise<AttemptStatisticsResponse> {
        const result = this.api.v1StatsEndpointAttempts(appId, endpointId, startDate, endDate, _options);
        return result.toPromise();
    }


}



import { ObservableStreamApi } from './ObservableAPI';

import { StreamApiRequestFactory, StreamApiResponseProcessor} from "../apis/StreamApi";
export class PromiseStreamApi {
    private api: ObservableStreamApi

    public constructor(
        configuration: Configuration,
        requestFactory?: StreamApiRequestFactory,
        responseProcessor?: StreamApiResponseProcessor
    ) {
        this.api = new ObservableStreamApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Creates a new stream.
     * Create Stream
     * @param streamIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1StreamCreateWithHttpInfo(streamIn: StreamIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<StreamOut>> {
        const result = this.api.v1StreamCreateWithHttpInfo(streamIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Creates a new stream.
     * Create Stream
     * @param streamIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1StreamCreate(streamIn: StreamIn, idempotencyKey?: string, _options?: Configuration): Promise<StreamOut> {
        const result = this.api.v1StreamCreate(streamIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Creates events on the Stream.
     * Create Events
     * @param streamId
     * @param createStreamIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1StreamCreateEventsWithHttpInfo(streamId: string, createStreamIn: CreateStreamIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<any>> {
        const result = this.api.v1StreamCreateEventsWithHttpInfo(streamId, createStreamIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Creates events on the Stream.
     * Create Events
     * @param streamId
     * @param createStreamIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1StreamCreateEvents(streamId: string, createStreamIn: CreateStreamIn, idempotencyKey?: string, _options?: Configuration): Promise<any> {
        const result = this.api.v1StreamCreateEvents(streamId, createStreamIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Delete a stream.
     * Delete Stream
     * @param streamId
     */
    public v1StreamDeleteWithHttpInfo(streamId: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1StreamDeleteWithHttpInfo(streamId, _options);
        return result.toPromise();
    }

    /**
     * Delete a stream.
     * Delete Stream
     * @param streamId
     */
    public v1StreamDelete(streamId: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1StreamDelete(streamId, _options);
        return result.toPromise();
    }

    /**
     * Iterate over a stream of events.
     * Stream Events
     * @param streamId
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [after]
     */
    public v1StreamEventsGetWithHttpInfo(streamId: string, limit?: number, iterator?: string, after?: Date, _options?: Configuration): Promise<HttpInfo<EventStreamOut>> {
        const result = this.api.v1StreamEventsGetWithHttpInfo(streamId, limit, iterator, after, _options);
        return result.toPromise();
    }

    /**
     * Iterate over a stream of events.
     * Stream Events
     * @param streamId
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [after]
     */
    public v1StreamEventsGet(streamId: string, limit?: number, iterator?: string, after?: Date, _options?: Configuration): Promise<EventStreamOut> {
        const result = this.api.v1StreamEventsGet(streamId, limit, iterator, after, _options);
        return result.toPromise();
    }

    /**
     * Get a stream by id or uid.
     * Get Stream
     * @param streamId
     */
    public v1StreamGetWithHttpInfo(streamId: string, _options?: Configuration): Promise<HttpInfo<StreamOut>> {
        const result = this.api.v1StreamGetWithHttpInfo(streamId, _options);
        return result.toPromise();
    }

    /**
     * Get a stream by id or uid.
     * Get Stream
     * @param streamId
     */
    public v1StreamGet(streamId: string, _options?: Configuration): Promise<StreamOut> {
        const result = this.api.v1StreamGet(streamId, _options);
        return result.toPromise();
    }

    /**
     * List of all the organization\'s streams.
     * List Streams
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1StreamListWithHttpInfo(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<HttpInfo<ListResponseStreamOut>> {
        const result = this.api.v1StreamListWithHttpInfo(limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * List of all the organization\'s streams.
     * List Streams
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1StreamList(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<ListResponseStreamOut> {
        const result = this.api.v1StreamList(limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * Partially update a stream.
     * Patch Stream
     * @param streamId
     * @param streamPatch
     */
    public v1StreamPatchWithHttpInfo(streamId: string, streamPatch: StreamPatch, _options?: Configuration): Promise<HttpInfo<StreamOut>> {
        const result = this.api.v1StreamPatchWithHttpInfo(streamId, streamPatch, _options);
        return result.toPromise();
    }

    /**
     * Partially update a stream.
     * Patch Stream
     * @param streamId
     * @param streamPatch
     */
    public v1StreamPatch(streamId: string, streamPatch: StreamPatch, _options?: Configuration): Promise<StreamOut> {
        const result = this.api.v1StreamPatch(streamId, streamPatch, _options);
        return result.toPromise();
    }

    /**
     * Update a stream.
     * Update Stream
     * @param streamId
     * @param streamIn
     */
    public v1StreamUpdateWithHttpInfo(streamId: string, streamIn: StreamIn, _options?: Configuration): Promise<HttpInfo<StreamOut>> {
        const result = this.api.v1StreamUpdateWithHttpInfo(streamId, streamIn, _options);
        return result.toPromise();
    }

    /**
     * Update a stream.
     * Update Stream
     * @param streamId
     * @param streamIn
     */
    public v1StreamUpdate(streamId: string, streamIn: StreamIn, _options?: Configuration): Promise<StreamOut> {
        const result = this.api.v1StreamUpdate(streamId, streamIn, _options);
        return result.toPromise();
    }


}



import { ObservableStreamEventTypesApi } from './ObservableAPI';

import { StreamEventTypesApiRequestFactory, StreamEventTypesApiResponseProcessor} from "../apis/StreamEventTypesApi";
export class PromiseStreamEventTypesApi {
    private api: ObservableStreamEventTypesApi

    public constructor(
        configuration: Configuration,
        requestFactory?: StreamEventTypesApiRequestFactory,
        responseProcessor?: StreamEventTypesApiResponseProcessor
    ) {
        this.api = new ObservableStreamEventTypesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create an event type for Streams.
     * Create Stream Event Type
     * @param streamEventTypeIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1StreamEventTypeCreateWithHttpInfo(streamEventTypeIn: StreamEventTypeIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<StreamEventTypeOut>> {
        const result = this.api.v1StreamEventTypeCreateWithHttpInfo(streamEventTypeIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Create an event type for Streams.
     * Create Stream Event Type
     * @param streamEventTypeIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1StreamEventTypeCreate(streamEventTypeIn: StreamEventTypeIn, idempotencyKey?: string, _options?: Configuration): Promise<StreamEventTypeOut> {
        const result = this.api.v1StreamEventTypeCreate(streamEventTypeIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Delete an event type.
     * Delete Stream Event Type
     * @param name The event type\&#39;s name
     */
    public v1StreamEventTypeDeleteWithHttpInfo(name: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1StreamEventTypeDeleteWithHttpInfo(name, _options);
        return result.toPromise();
    }

    /**
     * Delete an event type.
     * Delete Stream Event Type
     * @param name The event type\&#39;s name
     */
    public v1StreamEventTypeDelete(name: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1StreamEventTypeDelete(name, _options);
        return result.toPromise();
    }

    /**
     * Get an event type.
     * Get Stream Event Type
     * @param name The event type\&#39;s name
     */
    public v1StreamEventTypeGetWithHttpInfo(name: string, _options?: Configuration): Promise<HttpInfo<StreamEventTypeOut>> {
        const result = this.api.v1StreamEventTypeGetWithHttpInfo(name, _options);
        return result.toPromise();
    }

    /**
     * Get an event type.
     * Get Stream Event Type
     * @param name The event type\&#39;s name
     */
    public v1StreamEventTypeGet(name: string, _options?: Configuration): Promise<StreamEventTypeOut> {
        const result = this.api.v1StreamEventTypeGet(name, _options);
        return result.toPromise();
    }

    /**
     * List of all the organization\'s event types for streaming.
     * List Stream Event Types
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1StreamEventTypeListWithHttpInfo(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<HttpInfo<ListResponseStreamEventTypeOut>> {
        const result = this.api.v1StreamEventTypeListWithHttpInfo(limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * List of all the organization\'s event types for streaming.
     * List Stream Event Types
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1StreamEventTypeList(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<ListResponseStreamEventTypeOut> {
        const result = this.api.v1StreamEventTypeList(limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * Patch an event type for Streams.
     * Patch Stream Event Type
     * @param name The event type\&#39;s name
     * @param streamEventTypePatch
     */
    public v1StreamEventTypePatchWithHttpInfo(name: string, streamEventTypePatch: StreamEventTypePatch, _options?: Configuration): Promise<HttpInfo<StreamEventTypeOut>> {
        const result = this.api.v1StreamEventTypePatchWithHttpInfo(name, streamEventTypePatch, _options);
        return result.toPromise();
    }

    /**
     * Patch an event type for Streams.
     * Patch Stream Event Type
     * @param name The event type\&#39;s name
     * @param streamEventTypePatch
     */
    public v1StreamEventTypePatch(name: string, streamEventTypePatch: StreamEventTypePatch, _options?: Configuration): Promise<StreamEventTypeOut> {
        const result = this.api.v1StreamEventTypePatch(name, streamEventTypePatch, _options);
        return result.toPromise();
    }

    /**
     * Update or create a event type for Streams.
     * Update Stream Event Type
     * @param name The event type\&#39;s name
     * @param streamEventTypeIn
     */
    public v1StreamEventTypeUpdateWithHttpInfo(name: string, streamEventTypeIn: StreamEventTypeIn, _options?: Configuration): Promise<HttpInfo<StreamEventTypeOut>> {
        const result = this.api.v1StreamEventTypeUpdateWithHttpInfo(name, streamEventTypeIn, _options);
        return result.toPromise();
    }

    /**
     * Update or create a event type for Streams.
     * Update Stream Event Type
     * @param name The event type\&#39;s name
     * @param streamEventTypeIn
     */
    public v1StreamEventTypeUpdate(name: string, streamEventTypeIn: StreamEventTypeIn, _options?: Configuration): Promise<StreamEventTypeOut> {
        const result = this.api.v1StreamEventTypeUpdate(name, streamEventTypeIn, _options);
        return result.toPromise();
    }


}



import { ObservableTransformationTemplateApi } from './ObservableAPI';

import { TransformationTemplateApiRequestFactory, TransformationTemplateApiResponseProcessor} from "../apis/TransformationTemplateApi";
export class PromiseTransformationTemplateApi {
    private api: ObservableTransformationTemplateApi

    public constructor(
        configuration: Configuration,
        requestFactory?: TransformationTemplateApiRequestFactory,
        responseProcessor?: TransformationTemplateApiResponseProcessor
    ) {
        this.api = new ObservableTransformationTemplateApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create/update endpoint Hubsport OAuth configuration Specific private endpoint just for us, to avoid exposing the Hubspot secret to the client.
     * Update Hubspot Oauth Config
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param hubspotOauthConfigIn
     */
    public v1EndpointUpdateHubspotOauthConfigWithHttpInfo(appId: string, endpointId: string, hubspotOauthConfigIn: HubspotOauthConfigIn, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1EndpointUpdateHubspotOauthConfigWithHttpInfo(appId, endpointId, hubspotOauthConfigIn, _options);
        return result.toPromise();
    }

    /**
     * Create/update endpoint Hubsport OAuth configuration Specific private endpoint just for us, to avoid exposing the Hubspot secret to the client.
     * Update Hubspot Oauth Config
     * @param appId The app\&#39;s ID or UID
     * @param endpointId The ep\&#39;s ID or UID
     * @param hubspotOauthConfigIn
     */
    public v1EndpointUpdateHubspotOauthConfig(appId: string, endpointId: string, hubspotOauthConfigIn: HubspotOauthConfigIn, _options?: Configuration): Promise<void> {
        const result = this.api.v1EndpointUpdateHubspotOauthConfig(appId, endpointId, hubspotOauthConfigIn, _options);
        return result.toPromise();
    }

    /**
     * Create a new transformation template
     * Create Transformation Template
     * @param templateIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1TransformationTemplateCreateWithHttpInfo(templateIn: TemplateIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<TemplateOut>> {
        const result = this.api.v1TransformationTemplateCreateWithHttpInfo(templateIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Create a new transformation template
     * Create Transformation Template
     * @param templateIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1TransformationTemplateCreate(templateIn: TemplateIn, idempotencyKey?: string, _options?: Configuration): Promise<TemplateOut> {
        const result = this.api.v1TransformationTemplateCreate(templateIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Delete a transformation template
     * Delete Transformation Template
     * @param transformationTemplateId
     */
    public v1TransformationTemplateDeleteWithHttpInfo(transformationTemplateId: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.v1TransformationTemplateDeleteWithHttpInfo(transformationTemplateId, _options);
        return result.toPromise();
    }

    /**
     * Delete a transformation template
     * Delete Transformation Template
     * @param transformationTemplateId
     */
    public v1TransformationTemplateDelete(transformationTemplateId: string, _options?: Configuration): Promise<void> {
        const result = this.api.v1TransformationTemplateDelete(transformationTemplateId, _options);
        return result.toPromise();
    }

    /**
     * Use OpenAI\'s Completion API to generate code for a transformation template
     * Generate
     * @param generateIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1TransformationTemplateGenerateWithHttpInfo(generateIn: GenerateIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<GenerateOut>> {
        const result = this.api.v1TransformationTemplateGenerateWithHttpInfo(generateIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Use OpenAI\'s Completion API to generate code for a transformation template
     * Generate
     * @param generateIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1TransformationTemplateGenerate(generateIn: GenerateIn, idempotencyKey?: string, _options?: Configuration): Promise<GenerateOut> {
        const result = this.api.v1TransformationTemplateGenerate(generateIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Get a transformation template
     * Get Transformation Template
     * @param transformationTemplateId
     */
    public v1TransformationTemplateGetWithHttpInfo(transformationTemplateId: string, _options?: Configuration): Promise<HttpInfo<TemplateOut>> {
        const result = this.api.v1TransformationTemplateGetWithHttpInfo(transformationTemplateId, _options);
        return result.toPromise();
    }

    /**
     * Get a transformation template
     * Get Transformation Template
     * @param transformationTemplateId
     */
    public v1TransformationTemplateGet(transformationTemplateId: string, _options?: Configuration): Promise<TemplateOut> {
        const result = this.api.v1TransformationTemplateGet(transformationTemplateId, _options);
        return result.toPromise();
    }

    /**
     * List all transformation templates for an application
     * List Transformation Templates
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1TransformationTemplateListWithHttpInfo(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<HttpInfo<ListResponseTemplateOut>> {
        const result = this.api.v1TransformationTemplateListWithHttpInfo(limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * List all transformation templates for an application
     * List Transformation Templates
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public v1TransformationTemplateList(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<ListResponseTemplateOut> {
        const result = this.api.v1TransformationTemplateList(limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * Get Discord Incoming webhook URL
     * Authorize Discord
     * @param oAuthPayloadIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1TransformationTemplateOauthDiscordWithHttpInfo(oAuthPayloadIn: OAuthPayloadIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<IncomingWebhookPayloadOut>> {
        const result = this.api.v1TransformationTemplateOauthDiscordWithHttpInfo(oAuthPayloadIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Get Discord Incoming webhook URL
     * Authorize Discord
     * @param oAuthPayloadIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1TransformationTemplateOauthDiscord(oAuthPayloadIn: OAuthPayloadIn, idempotencyKey?: string, _options?: Configuration): Promise<IncomingWebhookPayloadOut> {
        const result = this.api.v1TransformationTemplateOauthDiscord(oAuthPayloadIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Get Hubspot access token using authorization code
     * Authorize Hubspot
     * @param oAuthPayloadIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1TransformationTemplateOauthHubspotWithHttpInfo(oAuthPayloadIn: OAuthPayloadIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<OAuthPayloadOut>> {
        const result = this.api.v1TransformationTemplateOauthHubspotWithHttpInfo(oAuthPayloadIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Get Hubspot access token using authorization code
     * Authorize Hubspot
     * @param oAuthPayloadIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1TransformationTemplateOauthHubspot(oAuthPayloadIn: OAuthPayloadIn, idempotencyKey?: string, _options?: Configuration): Promise<OAuthPayloadOut> {
        const result = this.api.v1TransformationTemplateOauthHubspot(oAuthPayloadIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Get Slack Incoming webhook URL
     * Authorize Slack
     * @param oAuthPayloadIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1TransformationTemplateOauthSlackWithHttpInfo(oAuthPayloadIn: OAuthPayloadIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<IncomingWebhookPayloadOut>> {
        const result = this.api.v1TransformationTemplateOauthSlackWithHttpInfo(oAuthPayloadIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Get Slack Incoming webhook URL
     * Authorize Slack
     * @param oAuthPayloadIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1TransformationTemplateOauthSlack(oAuthPayloadIn: OAuthPayloadIn, idempotencyKey?: string, _options?: Configuration): Promise<IncomingWebhookPayloadOut> {
        const result = this.api.v1TransformationTemplateOauthSlack(oAuthPayloadIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Partially update a transformation template
     * Patch Transformation Template
     * @param transformationTemplateId
     * @param templatePatch
     */
    public v1TransformationTemplatePatchWithHttpInfo(transformationTemplateId: string, templatePatch: TemplatePatch, _options?: Configuration): Promise<HttpInfo<TemplateOut>> {
        const result = this.api.v1TransformationTemplatePatchWithHttpInfo(transformationTemplateId, templatePatch, _options);
        return result.toPromise();
    }

    /**
     * Partially update a transformation template
     * Patch Transformation Template
     * @param transformationTemplateId
     * @param templatePatch
     */
    public v1TransformationTemplatePatch(transformationTemplateId: string, templatePatch: TemplatePatch, _options?: Configuration): Promise<TemplateOut> {
        const result = this.api.v1TransformationTemplatePatch(transformationTemplateId, templatePatch, _options);
        return result.toPromise();
    }

    /**
     * Simulate running the transformation on the payload and code
     * Simulate
     * @param transformationSimulateIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1TransformationTemplateSimulateWithHttpInfo(transformationSimulateIn: TransformationSimulateIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<TransformationSimulateOut>> {
        const result = this.api.v1TransformationTemplateSimulateWithHttpInfo(transformationSimulateIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Simulate running the transformation on the payload and code
     * Simulate
     * @param transformationSimulateIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public v1TransformationTemplateSimulate(transformationSimulateIn: TransformationSimulateIn, idempotencyKey?: string, _options?: Configuration): Promise<TransformationSimulateOut> {
        const result = this.api.v1TransformationTemplateSimulate(transformationSimulateIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Update a transformation template
     * Update Transformation Template
     * @param transformationTemplateId
     * @param templateUpdate
     */
    public v1TransformationTemplateUpdateWithHttpInfo(transformationTemplateId: string, templateUpdate: TemplateUpdate, _options?: Configuration): Promise<HttpInfo<TemplateOut>> {
        const result = this.api.v1TransformationTemplateUpdateWithHttpInfo(transformationTemplateId, templateUpdate, _options);
        return result.toPromise();
    }

    /**
     * Update a transformation template
     * Update Transformation Template
     * @param transformationTemplateId
     * @param templateUpdate
     */
    public v1TransformationTemplateUpdate(transformationTemplateId: string, templateUpdate: TemplateUpdate, _options?: Configuration): Promise<TemplateOut> {
        const result = this.api.v1TransformationTemplateUpdate(transformationTemplateId, templateUpdate, _options);
        return result.toPromise();
    }


}



import { ObservableWebhookEndpointApi } from './ObservableAPI';

import { WebhookEndpointApiRequestFactory, WebhookEndpointApiResponseProcessor} from "../apis/WebhookEndpointApi";
export class PromiseWebhookEndpointApi {
    private api: ObservableWebhookEndpointApi

    public constructor(
        configuration: Configuration,
        requestFactory?: WebhookEndpointApiRequestFactory,
        responseProcessor?: WebhookEndpointApiResponseProcessor
    ) {
        this.api = new ObservableWebhookEndpointApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Create an operational webhook endpoint.
     * Create Operational Webhook Endpoint
     * @param operationalWebhookEndpointIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public createOperationalWebhookEndpointWithHttpInfo(operationalWebhookEndpointIn: OperationalWebhookEndpointIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<OperationalWebhookEndpointOut>> {
        const result = this.api.createOperationalWebhookEndpointWithHttpInfo(operationalWebhookEndpointIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Create an operational webhook endpoint.
     * Create Operational Webhook Endpoint
     * @param operationalWebhookEndpointIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public createOperationalWebhookEndpoint(operationalWebhookEndpointIn: OperationalWebhookEndpointIn, idempotencyKey?: string, _options?: Configuration): Promise<OperationalWebhookEndpointOut> {
        const result = this.api.createOperationalWebhookEndpoint(operationalWebhookEndpointIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Delete an operational webhook endpoint.
     * Delete Operational Webhook Endpoint
     * @param endpointId The ep\&#39;s ID or UID
     */
    public deleteOperationalWebhookEndpointWithHttpInfo(endpointId: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.deleteOperationalWebhookEndpointWithHttpInfo(endpointId, _options);
        return result.toPromise();
    }

    /**
     * Delete an operational webhook endpoint.
     * Delete Operational Webhook Endpoint
     * @param endpointId The ep\&#39;s ID or UID
     */
    public deleteOperationalWebhookEndpoint(endpointId: string, _options?: Configuration): Promise<void> {
        const result = this.api.deleteOperationalWebhookEndpoint(endpointId, _options);
        return result.toPromise();
    }

    /**
     * Get an operational webhook endpoint.
     * Get Operational Webhook Endpoint
     * @param endpointId The ep\&#39;s ID or UID
     */
    public getOperationalWebhookEndpointWithHttpInfo(endpointId: string, _options?: Configuration): Promise<HttpInfo<OperationalWebhookEndpointOut>> {
        const result = this.api.getOperationalWebhookEndpointWithHttpInfo(endpointId, _options);
        return result.toPromise();
    }

    /**
     * Get an operational webhook endpoint.
     * Get Operational Webhook Endpoint
     * @param endpointId The ep\&#39;s ID or UID
     */
    public getOperationalWebhookEndpoint(endpointId: string, _options?: Configuration): Promise<OperationalWebhookEndpointOut> {
        const result = this.api.getOperationalWebhookEndpoint(endpointId, _options);
        return result.toPromise();
    }

    /**
     * Get an operational webhook endpoint\'s signing secret.  This is used to verify the authenticity of the webhook. For more information please refer to [the consuming webhooks docs](https://docs.svix.com/consuming-webhooks/).
     * Get Operational Webhook Endpoint Secret
     * @param endpointId The ep\&#39;s ID or UID
     */
    public getOperationalWebhookEndpointSecretWithHttpInfo(endpointId: string, _options?: Configuration): Promise<HttpInfo<OperationalWebhookEndpointSecretOut>> {
        const result = this.api.getOperationalWebhookEndpointSecretWithHttpInfo(endpointId, _options);
        return result.toPromise();
    }

    /**
     * Get an operational webhook endpoint\'s signing secret.  This is used to verify the authenticity of the webhook. For more information please refer to [the consuming webhooks docs](https://docs.svix.com/consuming-webhooks/).
     * Get Operational Webhook Endpoint Secret
     * @param endpointId The ep\&#39;s ID or UID
     */
    public getOperationalWebhookEndpointSecret(endpointId: string, _options?: Configuration): Promise<OperationalWebhookEndpointSecretOut> {
        const result = this.api.getOperationalWebhookEndpointSecret(endpointId, _options);
        return result.toPromise();
    }

    /**
     * List operational webhook endpoints.
     * List Operational Webhook Endpoints
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public listOperationalWebhookEndpointsWithHttpInfo(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<HttpInfo<ListResponseOperationalWebhookEndpointOut>> {
        const result = this.api.listOperationalWebhookEndpointsWithHttpInfo(limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * List operational webhook endpoints.
     * List Operational Webhook Endpoints
     * @param [limit] Limit the number of returned items
     * @param [iterator] The iterator returned from a prior invocation
     * @param [order] The sorting order of the returned items
     */
    public listOperationalWebhookEndpoints(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Promise<ListResponseOperationalWebhookEndpointOut> {
        const result = this.api.listOperationalWebhookEndpoints(limit, iterator, order, _options);
        return result.toPromise();
    }

    /**
     * Rotates an operational webhook endpoint\'s signing secret.  The previous secret will remain valid for the next 24 hours.
     * Rotate Operational Webhook Endpoint Secret
     * @param endpointId The ep\&#39;s ID or UID
     * @param operationalWebhookEndpointSecretIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public rotateOperationalWebhookEndpointSecretWithHttpInfo(endpointId: string, operationalWebhookEndpointSecretIn: OperationalWebhookEndpointSecretIn, idempotencyKey?: string, _options?: Configuration): Promise<HttpInfo<void>> {
        const result = this.api.rotateOperationalWebhookEndpointSecretWithHttpInfo(endpointId, operationalWebhookEndpointSecretIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Rotates an operational webhook endpoint\'s signing secret.  The previous secret will remain valid for the next 24 hours.
     * Rotate Operational Webhook Endpoint Secret
     * @param endpointId The ep\&#39;s ID or UID
     * @param operationalWebhookEndpointSecretIn
     * @param [idempotencyKey] The request\&#39;s idempotency key
     */
    public rotateOperationalWebhookEndpointSecret(endpointId: string, operationalWebhookEndpointSecretIn: OperationalWebhookEndpointSecretIn, idempotencyKey?: string, _options?: Configuration): Promise<void> {
        const result = this.api.rotateOperationalWebhookEndpointSecret(endpointId, operationalWebhookEndpointSecretIn, idempotencyKey, _options);
        return result.toPromise();
    }

    /**
     * Update an operational webhook endpoint.
     * Update Operational Webhook Endpoint
     * @param endpointId The ep\&#39;s ID or UID
     * @param operationalWebhookEndpointUpdate
     */
    public updateOperationalWebhookEndpointWithHttpInfo(endpointId: string, operationalWebhookEndpointUpdate: OperationalWebhookEndpointUpdate, _options?: Configuration): Promise<HttpInfo<OperationalWebhookEndpointOut>> {
        const result = this.api.updateOperationalWebhookEndpointWithHttpInfo(endpointId, operationalWebhookEndpointUpdate, _options);
        return result.toPromise();
    }

    /**
     * Update an operational webhook endpoint.
     * Update Operational Webhook Endpoint
     * @param endpointId The ep\&#39;s ID or UID
     * @param operationalWebhookEndpointUpdate
     */
    public updateOperationalWebhookEndpoint(endpointId: string, operationalWebhookEndpointUpdate: OperationalWebhookEndpointUpdate, _options?: Configuration): Promise<OperationalWebhookEndpointOut> {
        const result = this.api.updateOperationalWebhookEndpoint(endpointId, operationalWebhookEndpointUpdate, _options);
        return result.toPromise();
    }


}



